<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="好像没什么比自由更加重要了">
<meta property="og:type" content="website">
<meta property="og:title" content="厨子张">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="厨子张">
<meta property="og:description" content="好像没什么比自由更加重要了">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="厨子张">
<meta name="twitter:description" content="好像没什么比自由更加重要了">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title> 厨子张 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">厨子张</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/12-下标/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ChefZhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://upload-images.jianshu.io/upload_images/328309-f0893d1d69f1787d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="厨子张">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="厨子张" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/12-下标/" itemprop="url">
                  12.下标
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T17:59:42+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift基本语法/" itemprop="url" rel="index">
                    <span itemprop="name">swift基本语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/24/12-下标/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/24/12-下标/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p>下标可以定义在==类、结构体和枚举==中，是访问集合，列表或序列中元素的快捷方式。可以使用下标的索引，设置 和获取值，而不需要再调用对应的存取方法。举例来说，用下标访问一个<code>Array</code> 实例中的元素可以写作 <code>someArray[index]</code> ，访问<code>Dictionary</code> 实例中的元素可以写作 <code>someDictionary[key]</code> 。</p>
<p>一个类型可以定义多个下标，通过不同索引类型进行重载。下标不限于一维，你可以定义具有多个入参的下标满足自定义类型的需求。</p>
<h3 id="下标语法"><a href="#下标语法" class="headerlink" title="下标语法"></a>下标语法</h3><p>下标允许你通过在==实例名称==后面的==方括号==中传入<em>一个或者多个索引值</em>来对实例进行存取。语法类似于实例方法语 法和计算型属性语法的混合。与定义实例方法类似，定义下标使用<code>subscript</code> 关键字，指定一个或多个输入参数 和返回类型;与实例方法不同的是，下标可以设定为读写或只读。这种行为由 getter 和 setter 实现，有点类 似计算型属性:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;    <span class="keyword">get</span> &#123;	<span class="comment">// 返回一个适当的 Int 类型的值 </span></div><div class="line">	&#125;	<span class="keyword">set</span>(newValue) &#123;	<span class="comment">// 执行适当的赋值操作</span>	&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>newValue</code>的类型和下标的返回类型相同。如同计算型属性，可以不指定 setter 的参数(<code>newValue</code> )。如果不 指定参数，setter 会提供一个名为<code>newValue</code> 的默认参数。</p>
<p>如同只读计算型属性，可以省略只读下标的<code>get</code> 关键字:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;<span class="comment">// 返回一个适当的 Int 类型的值</span>&#125;</div></pre></td></tr></table></figure>
<p>下面代码演示了只读下标的实现，这里定义了一个 TimesTable 结构体，用来表示传入整数的乘法表:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TimesTable</span> </span>&#123;     <span class="keyword">let</span> multiplier: <span class="type">Int</span>     <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;         <span class="keyword">return</span> multiplier * index     &#125;&#125;<span class="keyword">let</span> threeTimesTable = <span class="type">TimesTable</span>(multiplier: <span class="number">3</span>) <span class="built_in">print</span>(<span class="string">"six times three is <span class="subst">\(threeTimesTable[<span class="number">6</span>])</span>"</span>) </div><div class="line"><span class="comment">// 打印 "six times three is 18"</span></div></pre></td></tr></table></figure>
<h3 id="下标用法"><a href="#下标用法" class="headerlink" title="下标用法"></a>下标用法</h3><p>下标的确切含义取决于使用场景。下标通常作为访问 合，列表或序列中元素的快捷方式。你可以针对自己特定的类或结构体的功能来自由地以最恰当的方式实现下标。</p>
<p>例如，Swift 的 Dictionary 类型实现下标用于对其实例中储存的值进行存取操作。为字典设值时，在下标中使用 和字典的键类型相同的键，并把一个和字典的值类型相同的值赋给这个下标:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numberOfLegs = [<span class="string">"spider"</span>: <span class="number">8</span>, <span class="string">"ant"</span>: <span class="number">6</span>, <span class="string">"cat"</span>: <span class="number">4</span>]numberOfLegs[<span class="string">"bird"</span>] = <span class="number">2</span></div></pre></td></tr></table></figure>
<p>上例定义一个名为 numberOfLegs 的变量，并用一个包含三对键值的字典字面量初始化它。 numberOfLegs 字典的 类型被推断为 [String: Int] 。字典创建完成后，该例子通过下标将 String 类型的键 bird 和 Int 类型的值 2 添 加到字典中。</p>
<h3 id="下标选项"><a href="#下标选项" class="headerlink" title="下标选项"></a>下标选项</h3><p>下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。</p>
<p>一个类或结构体可以根据自身需要提供多个下标实现，使用下标时将通过入参的数量和类型进行区分，自动匹配合适的下标，这就是下标的重载。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span>, columns: <span class="type">Int</span></div><div class="line">    <span class="keyword">var</span> grid: [<span class="type">Double</span>]</div><div class="line">    <span class="keyword">init</span>(rows: <span class="type">Int</span>, columns: <span class="type">Int</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.rows = rows</div><div class="line">        <span class="keyword">self</span>.columns = columns</div><div class="line">        grid = <span class="type">Array</span>(repeating: <span class="number">0.0</span>, <span class="built_in">count</span>: rows * columns)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">indexIsValidForRow</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; columns</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">subscript</span>(row: <span class="type">Int</span>, column: <span class="type">Int</span>) -&gt; <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="built_in">assert</span>(indexIsValidForRow(row: row, column: column), <span class="string">"Index out of range"</span>)</div><div class="line">            <span class="keyword">return</span> grid[(row * columns) + column]</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            <span class="built_in">assert</span>(indexIsValidForRow(row: row, column: column), <span class="string">"Index out of range"</span>)</div><div class="line">            grid[(row * columns) + column] = newValue</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> matrix = <span class="type">Matrix</span>(rows: <span class="number">2</span>, columns: <span class="number">2</span>)</div><div class="line">matrix[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">1.5</span></div><div class="line">matrix[<span class="number">1</span>, <span class="number">0</span>] = <span class="number">3.2</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(matrix.grid)</div><div class="line"><span class="comment">// "[0.0, 1.5, 3.2000000000000002, 0.0]\n"</span></div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/11-方法/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ChefZhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://upload-images.jianshu.io/upload_images/328309-f0893d1d69f1787d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="厨子张">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="厨子张" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/11-方法/" itemprop="url">
                  11.方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T17:59:22+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift基本语法/" itemprop="url" rel="index">
                    <span itemprop="name">swift基本语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/24/11-方法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/24/11-方法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是与某些特定类型相关联的函数。<br>类、结构体、枚举都可以定义实例方法;实例方法为给定类型的实例封装 了具体的任务与功能。<br>类、结构体、枚举也可以定义类型方法;类型方法与类型本身相关联。类型方法与 Object ive-C 中的类方法(class methods)相似。</p>
<h3 id="实例方法-Instance-Methods"><a href="#实例方法-Instance-Methods" class="headerlink" title="实例方法 (Instance Methods)"></a>实例方法 (Instance Methods)</h3><p>实例方法的语法与函数完全一致</p>
<p>实例方法要写在它所属的类型的前后大括号之间。实例方法能够<code>隐式访问</code>（不写<code>self.</code>）它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法不能脱离于现存的实例而被调用。</p>
<p>下面的例子，定义一个很简单的 Counter 类， Counter 能被用来对一个动作发生的次数进行计数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">count</span> += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(by amount: Int)</span></span> &#123;</div><div class="line">        <span class="built_in">count</span> += amount</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">count</span> = <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="type">Counter</span>()</div><div class="line"><span class="built_in">count</span>.increment(by: <span class="number">15</span>)</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="built_in">count</span>.<span class="built_in">count</span>)</div></pre></td></tr></table></figure>
<h4 id="self-属性"><a href="#self-属性" class="headerlink" title="self 属性"></a>self 属性</h4><p>类型的每一个实例都有一个隐含属性叫做<code>self</code> ，<code>self</code> 完全等同于该实例本身。你可以在一个实例的实例方法中 使用这个隐含的<code>self</code> 属性来引用当前实例。</p>
<p>上面例子中的 increment 方法还可以这样写:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;     <span class="keyword">self</span>.<span class="built_in">count</span> += <span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<p>使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名 称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用 self 属性来区分参数名称和属性 名称。</p>
<p>下面的例子中， self 消除方法参数 x 和实例属性 x 之间的歧义:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isToTheRightOfX</span><span class="params">(x: Double)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.x &gt; x</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> somePoint = <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">5.0</span>)</div><div class="line"><span class="keyword">if</span> somePoint.isToTheRightOfX(x: <span class="number">1.0</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"This point is to the right of the line where x == 1.0"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "This point is to the right of the line where x == 1.0"</span></div></pre></td></tr></table></figure>
<h4 id="在实例方法中修改值类型"><a href="#在实例方法中修改值类型" class="headerlink" title="在实例方法中修改值类型"></a>在实例方法中修改值类型</h4><p>==结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。==</p>
<p>但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择 可变(<code>mutating</code>) 行为，然后就可以从其方法内部改变它的属性;并且这个方法做的任何改变都会在方法执行结束时写回到原始 结构中。==方法还可以给它隐含的 self 属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。==</p>
<p>要使用<code>可变</code>方法，将关键字<code>mutating</code>放到方法的<code>func</code>关键字之前就可以了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveByX</span><span class="params">(deltaX: Double, y deltaY: Double)</span></span> &#123;</div><div class="line">        x += deltaX</div><div class="line">        y += deltaY</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> somePoint = <span class="type">Point</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</div><div class="line">somePoint.moveByX(deltaX: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"The point is now at (<span class="subst">\(somePoint.x)</span>, <span class="subst">\(somePoint.y)</span>)"</span>)</div><div class="line"><span class="comment">// 打印 "The point is now at (3.0, 4.0)"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意，不能在结构体类型的常量(a constant of structure type)上调用可变方法，因为其属性不能被改 变，即使属性是变量属性</p>
</blockquote>
<h4 id="在可变方法中给-self-赋值"><a href="#在可变方法中给-self-赋值" class="headerlink" title="在可变方法中给 self 赋值"></a>在可变方法中给 self 赋值</h4><p>可变方法能够赋给隐含属性 self 一个全新的实例。上面<code>Point</code> 的例子可以用下面的方式改写:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point1</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveBy</span><span class="params">(x deltaX: Double, y deltaY: Double)</span></span> &#123;</div><div class="line">        <span class="keyword">self</span> = <span class="type">Point1</span>(x: x + deltaX, y: y + deltaY)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="type">Point1</span>(x: <span class="number">2</span>, y: <span class="number">3.2</span>)</div><div class="line">x.moveBy(x: <span class="number">5</span>, y: <span class="number">2</span>)</div><div class="line"><span class="built_in">print</span>(x)</div></pre></td></tr></table></figure>
<p>枚举的可变方法可以把 self 设置为同一枚举类型中不同的成员:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TriStateSwitch</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Off</span>, <span class="type">Low</span>, <span class="type">High</span></div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">        <span class="keyword">case</span> .<span class="type">Off</span>:</div><div class="line">            <span class="keyword">self</span> = .<span class="type">Low</span></div><div class="line">        <span class="keyword">case</span> .<span class="type">Low</span>:</div><div class="line">            <span class="keyword">self</span> = .<span class="type">High</span></div><div class="line">        <span class="keyword">case</span> .<span class="type">High</span>:</div><div class="line">            <span class="keyword">self</span> = .<span class="type">Off</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> ovenLight = <span class="type">TriStateSwitch</span>.<span class="type">Low</span></div><div class="line">ovenLight.next()</div><div class="line"><span class="comment">// ovenLight 现在等于 .High </span></div><div class="line">ovenLight.next()</div><div class="line"><span class="comment">// ovenLight 现在等于 .Off</span></div></pre></td></tr></table></figure>
<h3 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h3><p>实例方法是被某个类型的实例调用的方法。你也可以定义在类型本身上调用的方法，这种方法就叫做类型方 法。</p>
<p>在方法的<code>func</code> 关键字之前加上关键字<code>static</code> ，来指定类型方法。<br>类还可以用关键字<code>class</code> 来允许子类重写 父类的方法实现。</p>
<blockquote>
<p>注意<br>在 Objective-C 中，你只能为 Objective-C 的类类型(classes)定义类型方法(type-level methods)。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">someTypeMethod</span>() </span>&#123;</div><div class="line">        <span class="comment">// 在这里实现类型方法 </span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="type">SomeClass</span>.someTypeMethod()</div></pre></td></tr></table></figure>
<p>在类型方法的方法体(body)中，<code>self</code> 指向这个类型本身，而不是类型的某个实例。这意味着你可以用<code>self</code> 来 消除类型属性和类型方法参数之间的歧义(类似于我们在前面处理实例属性和实例方法参数时做的那样)。</p>
<p>一般来说，在类型方法的方法体中，任何未限定的方法和属性名称，可以被本类中其他的类型方法和类型属性引用。一个类型方法可以直接通过类型方法的名称调用本类中的其它类型方法，而无需在方法名称前面加上类型名称。类似地，在结构体和枚举中，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要前面加上类型名称。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LevelTracker</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> highestUnlockedLevel = <span class="number">1</span></div><div class="line">    <span class="keyword">var</span> currentLevel = <span class="number">1</span></div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">unlock</span><span class="params">(<span class="number">_</span> level: Int)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">isUnlocked</span><span class="params">(<span class="number">_</span> level: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> level &lt;= highestUnlockedLevel</div><div class="line">    &#125;</div><div class="line">    @discardableResult <span class="comment">//允许在调用 advance(to:) 时候忽略返回值，不会产生编译警告</span></div><div class="line">     <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">advance</span><span class="params">(to level: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="comment">// 用mutating修饰，表示 可以在该方法中修改它所属的实例以及实例的任意属性的值</span></div><div class="line">        <span class="keyword">if</span> <span class="type">LevelTracker</span>.isUnlocked(level) &#123;</div><div class="line">            currentLevel = level</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面， <code>Player</code>  类使用 <code>LevelTracker</code>来监测和更新每个玩家的发展进度:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;     <span class="keyword">var</span> tracker = <span class="type">LevelTracker</span>()     <span class="keyword">let</span> playerName: <span class="type">String</span>     <span class="function"><span class="keyword">func</span> <span class="title">complete</span><span class="params">(level: Int)</span></span> &#123;         <span class="type">LevelTracker</span>.unlock(level + <span class="number">1</span>)         tracker.<span class="built_in">advance</span>(to: level + <span class="number">1</span>)     &#125;     <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;         playerName = name     &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> player = <span class="type">Player</span>(name: <span class="string">"Argyrios"</span>)player.complete(level: <span class="number">1</span>)<span class="built_in">print</span>(<span class="string">"highest unlocked level is now <span class="subst">\(LevelTracker.highestUnlockedLevel)</span>"</span>) </div><div class="line"><span class="comment">// 打印 "highest unlocked level is now 2"</span></div></pre></td></tr></table></figure>
<p>如果你创建了第二个玩家，并尝试让他开始一个没有被任何玩家解锁的等级，那么试图设置玩家当前等级将会失败:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">player = <span class="type">Player</span>(name: <span class="string">"Beto"</span>) <span class="keyword">if</span> player.tracker.<span class="built_in">advance</span>(to: <span class="number">6</span>) &#123;     <span class="built_in">print</span>(<span class="string">"player is now on level 6"</span>) &#125; <span class="keyword">else</span> &#123;     <span class="built_in">print</span>(<span class="string">"level 6 has not yet been unlocked"</span>) &#125;<span class="comment">// 打印 "level 6 has not yet been unlocked"</span></div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/10-属性/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ChefZhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://upload-images.jianshu.io/upload_images/328309-f0893d1d69f1787d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="厨子张">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="厨子张" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/10-属性/" itemprop="url">
                  10.属性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T17:59:04+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift基本语法/" itemprop="url" rel="index">
                    <span itemprop="name">swift基本语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/24/10-属性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/24/10-属性/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算(不是存储)一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。</p>
<h3 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h3><p>简单来说，一个存储属性就是存储在<code>特定类</code>或<code>结构体</code>实例里的一个常量或变量。存储属性可以是变量存储属性(用关键字 var 定义)，也可以是常量存储属性(用关键字 let 定义)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FixedLengthRange</span> </span>&#123;     <span class="keyword">var</span> firstValue: <span class="type">Int</span>     <span class="keyword">let</span> length: <span class="type">Int</span>&#125;<span class="keyword">var</span> rangeOfThreeItems = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">3</span>) </div><div class="line"><span class="comment">// 该区间表示整数0，1，2</span>rangeOfThreeItems.firstValue = <span class="number">6</span><span class="comment">// 该区间现在表示整数6，7，8</span></div></pre></td></tr></table></figure>
<h4 id="常量结构体的存储属性"><a href="#常量结构体的存储属性" class="headerlink" title="常量结构体的存储属性"></a>常量结构体的存储属性</h4><p>如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rangeOfFourItems = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">4</span>) </div><div class="line"><span class="comment">// 该区间表示整数0，1，2，3</span>rangeOfFourItems.firstValue = <span class="number">6</span><span class="comment">// 尽管 firstValue 是个变量属性，这里还是会报错</span></div></pre></td></tr></table></figure>
<p>这种行为是由于结构体(struct)属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常 量。</p>
<p>属于引用类型的类(class)则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属 性。</p>
<h4 id="延迟存储属性（lazy）"><a href="#延迟存储属性（lazy）" class="headerlink" title="延迟存储属性（lazy）"></a>延迟存储属性（lazy）</h4><p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用<code>lazy</code> 来标示一个延迟存 储属性。</p>
<blockquote>
<p>注意<br>必须将延迟存储属性声明成变量(使用<code>var</code> 关键字)，因为属性的初始值可能在实例构造完成之后才会得 到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataImporter</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     DataImporter 是一个负责将外部文件中的数据导入的类。 这个类的初始化会消耗不少时间。</div><div class="line">     */</div><div class="line">    <span class="keyword">var</span> fileName = <span class="string">"data.txt"</span></div><div class="line">    <span class="comment">// 这里会提供数据导入功能 </span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> importer = <span class="type">DataImporter</span>()</div><div class="line">    <span class="keyword">var</span> data = [<span class="type">String</span>]()</div><div class="line">    <span class="comment">// 这里会提供数据管理功能</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> manager = <span class="type">DataManager</span>()</div><div class="line">manager.data.append(<span class="string">"Some data"</span>)</div><div class="line">manager.data.append(<span class="string">"Some more data"</span>)</div><div class="line"><span class="comment">// DataImporter 实例的 importer 属性还没有被创建</span></div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(manager.importer.fileName)<span class="comment">// DataImporter 实例的 importer 属性现在被创建了 </span></div><div class="line"><span class="comment">// 输出 "data.txt”</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一 次。</p>
</blockquote>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 getter 和一个可 选的 setter，来间接获取和设置其他属性或变量的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</div><div class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</div><div class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</div><div class="line">            <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</div><div class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span>(newCenter) &#123;</div><div class="line">            origin.x = newCenter.x - (size.width / <span class="number">2</span>)</div><div class="line">            origin.y = newCenter.y - (size.height / <span class="number">2</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> square = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>), size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</div><div class="line"><span class="keyword">let</span> initialSquareCenter = square.center</div><div class="line"><span class="built_in">print</span>(initialSquareCenter.x, initialSquareCenter.y)</div><div class="line"></div><div class="line">square.center = <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"square.origin is now at (<span class="subst">\(square.origin.x)</span>, <span class="subst">\(square.origin.y)</span>)"</span>)</div><div class="line"><span class="comment">// 打印 "square.origin is now at (10.0, 10.0)”</span></div></pre></td></tr></table></figure>
<h4 id="简化-setter-声明"><a href="#简化-setter-声明" class="headerlink" title="简化 setter 声明"></a>简化 setter 声明</h4><p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称<code>newValue</code> 。下面是使用了简化 setter 声明的 Rect 结构体代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlternativeRect</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</div><div class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</div><div class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</div><div class="line">            <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</div><div class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            origin.x = newValue.x - (size.width / <span class="number">2</span>)</div><div class="line">            origin.y = newValue.y - (size.height / <span class="number">2</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h4><p>只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访 问，但不能设置新的值。</p>
<blockquote>
<p>注意<br>必须使用   关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。 关键字只用来声明 常量属性，表示初始化后再也无法修改的值。</p>
</blockquote>
<p>只读计算属性的声明可以去掉 <code>get</code>  关键字和花括号:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cuboid</span> </span>&#123;     <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span>, depth = <span class="number">0.0</span>     <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;         <span class="keyword">return</span> width * height * depth     &#125;&#125;<span class="keyword">let</span> fourByFiveByTwo = <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>) <span class="built_in">print</span>(<span class="string">"the volume of fourByFiveByTwo is <span class="subst">\(fourByFiveByTwo.volume)</span>"</span>) </div><div class="line"><span class="comment">// 打印 "the volume of fourByFiveByTwo is 40.0"</span></div></pre></td></tr></table></figure>
<h3 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h3><p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。</p>
<p>可以为属性添加如下的一个或全部观察器:</p>
<ul>
<li><code>willSet</code>在新的值被设置之前调用</li>
<li><code>didSet</code>在新的值被设置之后立即调用</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> = <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">willSet</span>(newTotalSteps) &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"About to set totalSteps to <span class="subst">\(newTotalSteps)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">didSet</span> &#123;</div><div class="line">            <span class="keyword">if</span> totalSteps &gt; oldValue  &#123;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"Added <span class="subst">\(totalSteps - oldValue)</span> steps"</span>)</div><div class="line">            &#125; &#125;</div><div class="line">    &#125; &#125;</div><div class="line"><span class="keyword">let</span> stepCounter = <span class="type">StepCounter</span>()</div><div class="line">stepCounter.totalSteps = <span class="number">200</span></div><div class="line"><span class="comment">// About to set totalSteps to 200</span></div><div class="line"><span class="comment">// Added 200 steps</span></div><div class="line"></div><div class="line">stepCounter.totalSteps = <span class="number">360</span></div><div class="line"><span class="comment">// About to set totalSteps to 360</span></div><div class="line"><span class="comment">// Added 160 steps</span></div><div class="line"></div><div class="line">stepCounter.totalSteps = <span class="number">896</span></div><div class="line"><span class="comment">// About to set totalSteps to 896</span></div><div class="line"><span class="comment">// Added 536 steps</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果将属性通过 in-out 方式传入函数，   和   也会调用。这是因为 in-out 参数采用了拷入 拷出模式:即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。</p>
</blockquote>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。</p>
<p>全局变量是在函数、方法、闭包或任何类型之外定义的变量。<br>局部变量是在函数、方法或闭包内部定义的变量。</p>
<p>前面章节提到的全局或局部变量都属于存储型变量，跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入。</p>
<p>另外，在全局或局部范围都可以定义计算型变量和为存储型变量定义观察器。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样。</p>
<blockquote>
<p>注意<br>全局的常量或变量都是延迟计算的，跟延迟存储属性 (页 0)相似，不同的地方在于，全局的常量或变量不需要 标记 lazy 修饰符。<br>局部范围的常量或变量从不延迟计算。</p>
</blockquote>
<h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><p>实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。</p>
<p>也可以为类型本身定义属性， ==无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。==</p>
<p>存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。</p>
<blockquote>
<p>注意 跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过 程中使用构造器给类型属性赋值。<br>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访 问，系统也保证只会对其进行一次初始化，并且不需要对其使用<code>lazy</code> 修饰符。</p>
</blockquote>
<h4 id="类型属性语法"><a href="#类型属性语法" class="headerlink" title="类型属性语法"></a>类型属性语法</h4><p>在 C 或 Objective-C 中，与某个类型关联的静态常量和静态变量，是作为全局(global)静态变量定义的。但 是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支 持的范围内。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">6</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">27</span></div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideableComputedTypeProperty</span>: <span class="title">Int</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">107</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取和设置类型属性的值"><a href="#获取和设置类型属性的值" class="headerlink" title="获取和设置类型属性的值"></a>获取和设置类型属性的值</h4><p>跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)<span class="comment">// 打印 "Some value." </span></div><div class="line"><span class="type">SomeStructure</span>.storedTypeProperty = <span class="string">"Another value."</span> </div><div class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)<span class="comment">// 打印 "Another value.” </span></div><div class="line"><span class="built_in">print</span>(<span class="type">SomeEnumeration</span>.computedTypeProperty) </div><div class="line"><span class="comment">// 打印 "6" </span></div><div class="line"><span class="built_in">print</span>(<span class="type">SomeClass</span>.computedTypeProperty)<span class="comment">// 打印 "27"</span></div></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AudioChannel</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">let</span> thresholdLevel = <span class="number">10</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> maxInputLevelForAllChannels = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> currentLevel: <span class="type">Int</span> = <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">didSet</span> &#123;</div><div class="line">            <span class="keyword">if</span> currentLevel &gt; <span class="type">AudioChannel</span>.thresholdLevel &#123;</div><div class="line">                <span class="comment">// 将当前音量限制在阀值之内</span></div><div class="line">                currentLevel = <span class="type">AudioChannel</span>.thresholdLevel</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> currentLevel &gt; <span class="type">AudioChannel</span>.maxInputLevelForAllChannels &#123;</div><div class="line">                <span class="comment">// 存储当前音量作为新的最大输入音量</span></div><div class="line">                <span class="type">AudioChannel</span>.maxInputLevelForAllChannels = currentLevel</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> leftChannel = <span class="type">AudioChannel</span>()</div><div class="line"><span class="keyword">var</span> rightChannel = <span class="type">AudioChannel</span>()</div><div class="line"></div><div class="line">leftChannel.currentLevel = <span class="number">7</span></div><div class="line"><span class="built_in">print</span>(leftChannel.currentLevel)</div><div class="line"><span class="comment">// 输出 "7" </span></div><div class="line"><span class="built_in">print</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)</div><div class="line"><span class="comment">// 输出 "7"</span></div><div class="line"></div><div class="line"></div><div class="line">rightChannel.currentLevel = <span class="number">11</span></div><div class="line"><span class="built_in">print</span>(rightChannel.currentLevel)</div><div class="line"><span class="comment">// 输出 "10" </span></div><div class="line"><span class="built_in">print</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)</div><div class="line"><span class="comment">// 输出 "10"</span></div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/9-类和结构体/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ChefZhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://upload-images.jianshu.io/upload_images/328309-f0893d1d69f1787d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="厨子张">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="厨子张" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/9-类和结构体/" itemprop="url">
                  9.类和结构体
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T17:58:45+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift基本语法/" itemprop="url" rel="index">
                    <span itemprop="name">swift基本语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/24/9-类和结构体/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/24/9-类和结构体/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h2><p>类和结构体是人们构建代码所用的一种通用且灵活的构造体。我们可以使用完全相同的语法规则来为类和结构体定义属性(常量、变量)和添加方法，从而扩展类和结构体的功能。</p>
<h3 id="类和结构体对比"><a href="#类和结构体对比" class="headerlink" title="类和结构体对比"></a>类和结构体对比</h3><p>Swift 中类和结构体有很多共同点。共同处在于:</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义下标操作使得可以通过下标语法来访问实例所包含的值</li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能 </li>
<li>实现协议以提供某种标准功能</li>
</ul>
<p>共有属性 <strong>属性，方法，下标，构造过程，扩展，和协议</strong>。</p>
<p>与结构体相比，类还有如下的附加功能:</p>
<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型 </li>
<li>析构器允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数允许对一个类的多次引用</li>
</ul>
<p>类对比与结构体多出 <strong>继承，类型转换，析构过程（释放内存），和自动引用计数。结构体是值类型，类是引用类型</strong></p>
<h4 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h4><p>类和结构体有着类似的定义方式。我们通过关键字 class 和 struct 来分别表示类和结构体，并在一对大括号中定 义它们的具体内容:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123; <span class="comment">// 在这里定义类</span> &#125;<span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;<span class="comment">// 在这里定义结构体 &#125;</span></div></pre></td></tr></table></figure>
<p>以下是定义结构体和定义类的示例:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;     <span class="keyword">var</span> width = <span class="number">0</span>     <span class="keyword">var</span> height = <span class="number">0</span> &#125;<span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</div><div class="line">     <span class="keyword">var</span> resolution = <span class="type">Resolution</span>()     <span class="keyword">var</span> interlaced = <span class="literal">false</span>     <span class="keyword">var</span> frameRate = <span class="number">0.0</span>     <span class="keyword">var</span> name: <span class="type">String</span>?&#125;</div></pre></td></tr></table></figure>
<h4 id="类和结构体实例"><a href="#类和结构体实例" class="headerlink" title="类和结构体实例"></a>类和结构体实例</h4><p>生成结构体和类实例的语法非常相似:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> someResolution = <span class="type">Resolution</span>()<span class="keyword">let</span> someVideoMode = <span class="type">VideoMode</span>()</div></pre></td></tr></table></figure>
<h4 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h4><p>通过使用点语法，你可以访问实例的属性。其语法规则是，实例名后面紧跟属性名，两者通过点号( <code>.</code> )连接:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"The width of someResolution is <span class="subst">\(someResolution.width)</span>"</span>)<span class="comment">// 打印 "The width of someResolution is 0"</span></div></pre></td></tr></table></figure>
<p>你也可以使用点语法为变量属性赋值:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">someVideoMode.resolution.width = <span class="number">1280</span><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is now <span class="subst">\(someVideoMode.resolution.width)</span>"</span>) <span class="comment">// 打印 "The width of someVideoMode is now 1280"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>与 Objective-C 语言不同的是，<strong>*Swift 允许直接设置结构体属性的子属性</strong>。上面的最后一个例子，就是直接设 置了 <code>someVideoMode</code> 中 <code>resolution</code> 属性的 <code>width</code> 这个子属性，以上操作并不需要重新为整个 <code>resolution</code> 属性设 置新值。</p>
</blockquote>
<h4 id="结构体类型的成员逐一构造器"><a href="#结构体类型的成员逐一构造器" class="headerlink" title="结构体类型的成员逐一构造器"></a>结构体类型的成员逐一构造器</h4><p>所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中:</p>
<p><strong><em>只有结构体才自带逐一构造器</em></strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> vga = <span class="type">Resolution</span>(width:<span class="number">640</span>, height: <span class="number">480</span>)</div></pre></td></tr></table></figure>
<p>与结构体不同，类实例没有默认的成员逐一构造器。</p>
<h3 id="结构体和枚举是值类型"><a href="#结构体和枚举是值类型" class="headerlink" title="结构体和枚举是值类型"></a>结构体和枚举是值类型</h3><p><em>值类型</em>被赋予给一个变量、常量或者被传递给一个函数的时候，其值会<em>被拷贝</em>。</p>
<p>在之前的章节中，我们已经大量使用了值类型。实际上，在 Swift 中，所有的基本类型:整数(Integer)、浮 点数(floating-point)、布尔值(Boolean)、字符串(string)、数组(array)和字典(dictionary)，都是 值类型，并且在底层都是以结构体的形式所实现。</p>
<p>在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属 性，在代码中传递的时候都会被复制。</p>
<p>请看下面这个示例，其使用了前一个示例中的<code>Resolution</code> 结构体</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> hd = <span class="type">Resolution</span>(width: <span class="number">1920</span>, height: <span class="number">1080</span>)<span class="keyword">var</span> cinema = hd</div></pre></td></tr></table></figure>
<p>尽管 hd 和 cinema 有着相同的宽(width)和高(heigh t)，但是在幕后它们是两个完全不同的实例。</p>
<h3 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h3><p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。</p>
<p>请看下面这个示例，其使用了之前定义的<code>VideoMode</code> 类:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> tenEighty = <span class="type">VideoMode</span>()tenEighty.resolution = hdtenEighty.interlaced = <span class="literal">true</span>tenEighty.name = <span class="string">"1080i"</span>tenEighty.frameRate = <span class="number">25.0</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> alsoTenEighty = tenEighty</div><div class="line">alsoTenEighty.frameRate = <span class="number">30.0</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"The frameRate property of tenEighty is now <span class="subst">\(tenEighty.frameRate)</span>"</span>)</div></pre></td></tr></table></figure>
<h4 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h4><p>因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。(对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。)</p>
<p>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒 等运算符:</p>
<ul>
<li>等价于(===)</li>
<li>不等价于( !== )</li>
</ul>
<p>运用这两个运算符检测两个常量或者变量是否引用同一个实例:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> tenEighty === alsoTenEighty &#123;     <span class="built_in">print</span>(<span class="string">"tenEighty and alsoTenEighty refer to the same Resolution instance."</span>)&#125;<span class="comment">//打印 "tenEighty and alsoTenEighty refer to the same Resolution instance."</span></div></pre></td></tr></table></figure>
<p>请注意，“等价于”(用三个等号表示， <code>===</code>)与“等于”(用两个等号表示， <code>==</code> )的不同:</p>
<ul>
<li>“等价于”表示两个类类型(class type)的常量或者变量引用同一个类实例。</li>
<li>“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。</li>
</ul>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>如果你有 C，C++ 或者 Objective-C 语言的经验，那么你也许会知道这些语言使用指针来引用内存中的地址。一 个引用某个引用类型实例的 Swift 常量或者变量，与 C 语言中的指针类似，<em>但是并不直接指向某个内存地址</em>，也不要求你使用星号( <code>*</code> )来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式 相同。</p>
<h3 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h3><p>在你的代码中，你可以使用类和结构体来定义你的自定义数据类型。</p>
<p>然而，结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。</p>
<p>按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体:</p>
<ul>
<li>该数据结构的主要目的是用来封装少量相关简单数据值。</li>
<li>有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。 </li>
<li>该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。</li>
<li>该数据结构不需要去继承另一个既有类型的属性或者行为。</li>
</ul>
<p>举例来说，以下情境中适合使用结构体:</p>
<ul>
<li>几何形状的大小，封装一个 width 属性和 height 属性，两者均为 Double 类型。 </li>
<li>一定范围内的路径，封装一个 start 属性和 length 属性，两者均为 Int 类型。 </li>
<li>三维坐标系内一点，封装 x ， y 和 z 属性，三者均为 Double 类型。</li>
</ul>
<p>在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的<br>自定义数据构造都应该是类，而非结构体。</p>
<h3 id="字符串、数组、和字典类型的赋值与复制行为"><a href="#字符串、数组、和字典类型的赋值与复制行为" class="headerlink" title="字符串、数组、和字典类型的赋值与复制行为"></a>字符串、数组、和字典类型的赋值与复制行为</h3><p>Swift 中，许多基本类型，诸如<code>String</code> ，<code>Array</code> 和<code>Dictionary</code> 类型均以结构体的形式实现。这意味着被赋值给 新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。</p>
<p>Objective-C 中<code>NSString</code> ，<code>NSArray</code> 和<code>NSDictionary</code> 类型均以类的形式实现，而并非结构体。它们在被赋值或 者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。</p>
<blockquote>
<p>注意 以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Sw ift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回 避赋值来保证性能最优化。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/8-枚举/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ChefZhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://upload-images.jianshu.io/upload_images/328309-f0893d1d69f1787d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="厨子张">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="厨子张" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/8-枚举/" itemprop="url">
                  8.枚举
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T17:51:52+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift基本语法/" itemprop="url" rel="index">
                    <span itemprop="name">swift基本语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/24/8-枚举/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/24/8-枚举/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h3><p>使用 <code>enum</code> 关键词来创建枚举并且把它们的整个定义放在一对大括号内:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;    <span class="keyword">case</span> north    <span class="keyword">case</span> south    <span class="keyword">case</span> east    <span class="keyword">case</span> west&#125;</div></pre></td></tr></table></figure>
<p>枚举中定义的值(如 <code>north</code> ， <code>south</code> ， <code>east</code> 和 <code>west</code> )是这个枚举的成员值(或成员)。你可以使用 <code>case</code> 关键 字来定义一个新的枚举成员值。</p>
<blockquote>
<p>注意<br>与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的<br>nt 例子中，<code>north</code> ，<code>south</code> ，<code>east</code> 和<code>west</code> 不会被隐式地赋值为 0 ， 1 ， 2 和 3 。相反，这些枚举成员本身 就是完备的值，这些值的类型是已经明确定义好的 CompassPoint 类型。</p>
</blockquote>
<p>多个成员值可以出现在同一行上，用逗号隔开:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> </span>&#123;    <span class="keyword">case</span> mercury, venus, earth, mars, jupiter, saturn, uranus, neptune&#125;</div></pre></td></tr></table></figure>
<p>每个枚举定义了一个全新的类型。像 Swift 中其他类型一样，它们的名字(例如<code>CompassPoint</code> 和<code>Planet</code> )应该 以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于读起来更加容易理解:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> directionToHead = <span class="type">CompassPoint</span>.west</div></pre></td></tr></table></figure>
<p><code>directionToHead</code>的类型可以在它被<code>CompassPoint</code> 的某个值初始化时推断出来。一旦 directionToHead 被声明为<code>CompassPoint</code> 类型，你可以使用更简短的点语法将其设置为另一个<code>CompassPoint</code> 的值:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">directionToHead = .east</div></pre></td></tr></table></figure>
<p>当<code>directionToHead</code> 的类型已知时，再次为其赋值可以省略枚举类型名。在使用具有显式类型的枚举值时，这种 写法让代码具有更好的可读性。</p>
<h3 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h3><p>有时候能够把其他类型的关联值和成员值一起存储起来会很有用。这能让你连同成员值一 起存储额外的自定义信息，并且你每次在代码中使用该枚举成员时，还可以修改这个关联值。</p>
<p>你可以定义 Swift 枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。枚 举的这种特性跟其他语言中的可识别联合(discriminated unions)，标签联合(tagged unions)，或者变 体(variants)相似。</p>
<p>例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品。有些商品上标有使用 <code>0</code> 到 <code>9</code> 的数字的 UPC 格式的一维条形码。每一个条形码都有一个代表“数字系统”的数字，该数字后接五位代表“厂商代码”的 数字，接下来是五位代表“产品代码”的数字。最后一个数字是“检查”位，用来验证代码是否被正确扫描:</p>
<p>其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO 8859-1 字符，并且可以编码一个最多拥有 2,953 个 字符的字符串:</p>
<p>这便于库存跟踪系统用包含四个整型值的元组存储 UPC 码，以及用任意长度的字符串储存 QR 码。</p>
<p>在 Swift 中，使用如下方式定义表示两种商品条形码的枚举:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;     <span class="keyword">case</span> upc(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)     <span class="keyword">case</span> qrCode(<span class="type">String</span>)&#125;</div></pre></td></tr></table></figure>
<p>以上代码可以这么理解:</p>
<p>“定义一个名为 <code>Barcode</code> 的枚举类型，它的一个成员值是具有 <code>(Int，Int，Int，Int)</code> 类型关联值的 upc ，另一个 成员值是具有 <code>String</code> 类型关联值的 qrCode 。”</p>
<p>这个定义不提供任何 <code>Int</code> 或 <code>String</code> 类型的关联值，它只是定义了，当 <code>Barcode</code> 常量和变量等于 <code>Barcode.upc</code> 或 <code>Barcode.qrCode</code> 时，可以存储的关联值的类型。</p>
<p>然后可以使用任意一种条形码类型创建新的条形码，例如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> productBarcode = <span class="type">Barcode</span>.upc(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>上面的例子创建了一个名为<code>productBarcode</code> 的变量，并将 <code>Barcode.upc</code> 赋值给它，关联的元组值为 <code>(8, 85909, 51 226, 3)</code> 。</p>
<p>同一个商品可以被分配一个不同类型的条形码，例如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">productBarcode = .qrCode(<span class="string">"ABCDEFGHIJKLMNOP"</span>)</div></pre></td></tr></table></figure>
<p>这时，原始的 <code>Barcode.upc</code> 和其整数关联值被新的 <code>Barcode.qrCode</code> 和其字符串关联值所替代。 Barcode 类型的常 量和变量可以存储一个 .upc 或者一个 .qrCode (连同它们的关联值)，<strong><em>但是在同一时间只能存储这两个值中的一 个</em></strong>。</p>
<p>像先前那样，可以使用一个 <code>switch</code> 语句来检查不同的条形码类型。然而，这一次，关联值可以被提取出来作为 <code>switch</code> 语句的一部分。你可以在 <code>switch</code> 的 <code>case</code> 分支代码中提取每个关联值作为一个常量(用 <code>let</code> 前缀)或者 作为一个变量(用 <code>var</code> 前缀)来使用:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> productBarcode &#123; <span class="keyword">case</span> .upc(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> manufacturer, <span class="keyword">let</span> product, <span class="keyword">let</span> check):     <span class="built_in">print</span>(<span class="string">"UPC: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>."</span>) <span class="keyword">case</span> .qrCode(<span class="keyword">let</span> productCode):     <span class="built_in">print</span>(<span class="string">"QR code: <span class="subst">\(productCode)</span>."</span>) &#125;<span class="comment">// 打印 "QR code: ABCDEFGHIJKLMNOP."</span></div></pre></td></tr></table></figure>
<p>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个<code>let</code>或者<code>var</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">switch</span> productBarcode &#123; <span class="keyword">case</span> <span class="keyword">let</span> .upc(numberSystem, manufacturer, product, check):     <span class="built_in">print</span>(<span class="string">"UPC: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>."</span>) <span class="keyword">case</span> <span class="keyword">let</span> .qrCode(productCode):     <span class="built_in">print</span>(<span class="string">"QR code: <span class="subst">\(productCode)</span>."</span>) &#125;<span class="comment">// 输出 "QR code: ABCDEFGHIJKLMNOP."</span></div></pre></td></tr></table></figure>
<h3 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h3><p>在关联值小节的条形码例子中，演示了如何声明存储不同类型关联值的枚举成员。作为关联值的替代选 择，枚举成员可以被默认值(称为原始值)预填充，这些原始值的类型必须相同。</p>
<p>这是一个使用 ASCII 码作为原始值的枚举:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 必须说明是Character类型，不然就报错</span></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> tab = <span class="string">"\t"</span></div><div class="line">    <span class="keyword">case</span> lineFeed = <span class="string">"\n"</span></div><div class="line">    <span class="keyword">case</span> carriageReturn = <span class="string">"\r"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。</p>
<h4 id="原始值的隐式赋值"><a href="#原始值的隐式赋值" class="headerlink" title="原始值的隐式赋值"></a>原始值的隐式赋值</h4><p>在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为 你赋值。</p>
<p>例如，当使用整数作为原始值时，隐式赋值的值依次递增 1 。如果第一个枚举成员没有设置原始值，其原始值将 为<code>0</code>。(String的话，默认是本身的字符串)</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;     <span class="keyword">case</span> mercury = <span class="number">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune&#125;</div></pre></td></tr></table></figure>
<p>在上面的例子中， Plant.mercury 的显式原始值为 1 ， Planet.venus 的隐式原始值为 2 ，依次类推。</p>
<p>下面的例子是 <code>CompassPoint</code> 枚举的细化，使用字符串类型的原始值来表示各个方向的名称:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span>: <span class="title">String</span> </span>&#123;     <span class="keyword">case</span> north, south, east, west&#125;</div></pre></td></tr></table></figure>
<p>上面例子中， <code>CompassPoint.south</code> 拥有隐式原始值 <code>south</code> ，依次类推。</p>
<h4 id="使用原始值初始化枚举实例"><a href="#使用原始值初始化枚举实例" class="headerlink" title="使用原始值初始化枚举实例"></a>使用原始值初始化枚举实例</h4><p>如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做 <code>rawValue</code> 的参数，参数类型即为原始值类型，返回值则是枚举成员或 <code>nil</code> 。你可以使用这个初始化方法来创建一个新的枚 举实例。</p>
<p>根据实际，只要String或者是Int都可以用<code>rawValue</code>创建</p>
<p>这个例子利用原始值 7 创建了枚举成员 <code>uranus</code> </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> possiblePlanet = <span class="type">Planet</span>(rawValue: <span class="number">7</span>)<span class="comment">// possiblePlanet 类型为 Planet? 值为 Planet.uranus</span></div></pre></td></tr></table></figure>
<h3 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h3><p>递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上<code>indirect</code> 来表示该成员可递归。</p>
<p>例如，下面的例子中，枚举类型存储了简单的算术表达式:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;    <span class="keyword">case</span> number(<span class="type">Int</span>)    <span class="keyword">indirect</span> <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)    <span class="keyword">indirect</span> <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)&#125;</div></pre></td></tr></table></figure>
<p>你也可以在枚举类型开头加上<code>indirect</code> 关键字来表明它的所有成员都是可递归的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;    <span class="keyword">case</span> number(<span class="type">Int</span>)    <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)    <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)&#125;</div></pre></td></tr></table></figure>
<p>上面定义的枚举类型可以存储三种算术表达式:纯数字、两个表达式相加、两个表达式相乘。枚举成员 addition 和 multiplication 的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。例如，表达式 (5 + 4) <em> 2 ，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支 持这种嵌套——这意味着枚举类型需要支持递归。下面的代码展示了使用 ArithmeticExpression 这个递归枚举创 建表达式 (5 + 4) </em> 2</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> five = <span class="type">ArithmeticExpression</span>.number(<span class="number">5</span>) <span class="keyword">let</span> four = <span class="type">ArithmeticExpression</span>.number(<span class="number">4</span>) <span class="keyword">let</span> sum = <span class="type">ArithmeticExpression</span>.addition(five, four) <span class="keyword">let</span> product = <span class="type">ArithmeticExpression</span>.multiplication(sum, <span class="type">ArithmeticExpression</span>.number(<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的<br>函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(<span class="number">_</span> expression: ArithmeticExpression)</span></span> -&gt; <span class="type">Int</span> &#123;     <span class="keyword">switch</span> expression &#123;     <span class="keyword">case</span> <span class="keyword">let</span> .number(value):         <span class="keyword">return</span> value     <span class="keyword">case</span> <span class="keyword">let</span> .addition(<span class="keyword">left</span>, <span class="keyword">right</span>):         <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) + evaluate(<span class="keyword">right</span>)     <span class="keyword">case</span> <span class="keyword">let</span> .multiplication(<span class="keyword">left</span>, <span class="keyword">right</span>):         <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) * evaluate(<span class="keyword">right</span>)     &#125;&#125;<span class="built_in">print</span>(evaluate(product)) <span class="comment">// 打印 "18"</span></div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/7-闭包/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ChefZhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://upload-images.jianshu.io/upload_images/328309-f0893d1d69f1787d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="厨子张">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="厨子张" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/7-闭包/" itemprop="url">
                  7.闭包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T17:48:49+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift基本语法/" itemprop="url" rel="index">
                    <span itemprop="name">swift基本语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/24/7-闭包/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/24/7-闭包/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h3><h4 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h4><p>闭包表达式语法有如下的一般形式:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span>     statements&#125;</div></pre></td></tr></table></figure>
<p>闭包表达式参数 可以是 in-out 参数，但不能设定默认值。也可以使用具名的可变参数(译者注:但是如果可变 参数不放在参数列表的最后一位的话，调用闭包的时时编译器将报错。可参考这里)。元组也可以作为参数和返 回值</p>
<p>下面的例子展示了之前 backward(<em>:</em>:) 函数对应的闭包表达式版本的代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> reversedNames = names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span>     <span class="keyword">return</span> s1 &gt; s2&#125;)</div></pre></td></tr></table></figure>
<p>这个例子也是闭包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMathResult</span><span class="params">(<span class="number">_</span> mathFunction: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>, a: <span class="type">Int</span>, b: <span class="type">Int</span>)&#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(a, b)</span>)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">printMathResult(&#123; (a: <span class="type">Int</span>, b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> a - b</div><div class="line">&#125;, a: <span class="number">5</span>, b: <span class="number">6</span>)</div></pre></td></tr></table></figure>
<h4 id="根据上下文推断类型"><a href="#根据上下文推断类型" class="headerlink" title="根据上下文推断类型"></a>根据上下文推断类型</h4><p>因为排序闭包函数是作为 <code>sorted(by:)</code> 方法的参数传入的，Swift 可以推断其参数和返回值的类型。 <code>sorted(by:)</code> 方法被一个字符串数组调用，因此其参数必须是 <code>(String, String) -&gt; Bool</code> 类型的函数。这意味着 <code>(String, String)</code> 和 <code>Bool</code> 类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头( <code>-&gt;</code> )和围绕在参数周围的括号也可以被省略:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = <span class="type">Person</span>()</div><div class="line">p1.age = <span class="number">12</span></div><div class="line"><span class="keyword">let</span> p2 = <span class="type">Person</span>()</div><div class="line">p2.age = <span class="number">212</span></div><div class="line"><span class="keyword">let</span> p3 = <span class="type">Person</span>()</div><div class="line">p3.age = <span class="number">122</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> arrPerson = [p1, p2, p3]</div><div class="line"><span class="comment">// 会自动推到出类型 </span></div><div class="line"><span class="comment">// arrPerson.sorted(by: &lt;#T##(Person, Person) -&gt; Bool#&gt;)</span></div><div class="line">arrPerson.sorted &#123; (p1, p2) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> age1 = p1.age, <span class="keyword">let</span> age2 = p2.age &#123;</div><div class="line">        <span class="keyword">return</span> age1 &gt; age2</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="单表达式闭包隐式返回"><a href="#单表达式闭包隐式返回" class="headerlink" title="单表达式闭包隐式返回"></a>单表达式闭包隐式返回</h4><p>单行表达式闭包可以通过省略 return 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>
<p>在这个例子中，<code>sorted(by:)</code> 方法的参数类型明确了闭包必须返回一个 <code>Bool</code> 类型值。因为闭包函数体只包含 了一个单一表达式( <code>s1 &gt; s2</code> )，该表达式返回 <code>Bool</code> 类型值，因此这里没有歧义， <code>return</code> 关键字可以省 略。</p>
<h4 id="参数名称缩写"><a href="#参数名称缩写" class="headerlink" title="参数名称缩写"></a>参数名称缩写</h4><p>Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过 <code>$0</code> ， <code>$1</code> ， <code>$2</code> 来顺序调用闭包的参数，以 此类推。</p>
<p>如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会 通过函数类型进行推断。 <code>in</code> 关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成:</p>
<h4 id="运算符方法"><a href="#运算符方法" class="headerlink" title="运算符方法"></a>运算符方法</h4><p>实际上还有一种更简短的方式来编写上面例子中的闭包表达式。Swift 的 <code>String</code> 类型定义了关于大于 号(<code>&gt;</code>)的字符串实现，其作为一个函数接受两个 <code>String</code> 类型的参数并返回 <code>Bool</code> 类型的值。而这正好与<code>sorted(by:)</code> 方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift 可以自动推断出 你想使用大于号的字符串函数实现:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &gt;)</div></pre></td></tr></table></figure>
<h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><p>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionThatTakesAClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123; <span class="comment">// 函数体部分</span>&#125;<span class="comment">// 以下是不使用尾随闭包进行函数调用 </span></div><div class="line">someFunctionThatTakesAClosure(closure: &#123;	<span class="comment">// 闭包主体部分 </span></div><div class="line">&#125;)<span class="comment">// 以下是使用尾随闭包进行函数调用 </span></div><div class="line">someFunctionThatTakesAClosure() &#123;	<span class="comment">// 闭包主体部分 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下例介绍了如何在 <code>map(_:)</code> 方法中使用尾随闭包将 <code>Int</code> 类型数组 <code>[16, 58, 510]</code> 转换为包含对应 <code>String</code> 类型的值的数组 <code>[&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code> :</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> digitNames = [     <span class="number">0</span>: <span class="string">"Zero"</span>, <span class="number">1</span>: <span class="string">"One"</span>, <span class="number">2</span>: <span class="string">"Two"</span>,   <span class="number">3</span>: <span class="string">"Three"</span>, <span class="number">4</span>: <span class="string">"Four"</span>,     <span class="number">5</span>: <span class="string">"Five"</span>, <span class="number">6</span>: <span class="string">"Six"</span>, <span class="number">7</span>: <span class="string">"Seven"</span>, <span class="number">8</span>: <span class="string">"Eight"</span>, <span class="number">9</span>: <span class="string">"Nine"</span> ] <span class="keyword">let</span> numbers = [<span class="number">16</span>, <span class="number">58</span>, <span class="number">510</span>]</div></pre></td></tr></table></figure>
<p> 你现在可以通过传递一个尾随闭包给 numbers 数组的 map(_:) 方法来创建对应的字符串版本数组:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">let</span> strings = numbers.<span class="built_in">map</span> &#123;     (number) -&gt; <span class="type">String</span> <span class="keyword">in</span>     <span class="keyword">var</span> number = number     <span class="keyword">var</span> output = <span class="string">""</span>     <span class="keyword">repeat</span> &#123;         output = digitNames[number % <span class="number">10</span>]! + output         number /= <span class="number">10</span>     &#125; <span class="keyword">while</span> number &gt; <span class="number">0</span>     <span class="keyword">return</span> output &#125;<span class="comment">// strings 常量被推断为字符串类型数组，即 [String] // 其值为 ["OneSix", "FiveEight", "FiveOneZero"]</span></div></pre></td></tr></table></figure>
<p><strong>在该例中，局部变量 <code>number</code> 的值由<code>闭包中的 number 参数获得</code>，因此可以在闭包函数体内对其进行修改，(<code>闭包或者函数的参数总是常量</code>)，闭包表达式指定了返回类型为 String ，以表明存储映射值的新数组类型为 String。</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">test22</span><span class="params">(a: Int, b: String)</span></span> &#123;</div><div class="line"><span class="comment">// 这里会报错</span></div><div class="line">    a = a - <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h3><p>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>
<p>Swift 中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可 以捕获其外部函数所有的参数以及定义的常量和变量。</p>
<p>举个例子，这有一个叫做 <code>makeIncrementor</code> 的函数，其包含了一个叫做 <code>incrementor</code> 的嵌套函数。嵌套函数 <code>incrementor()</code> 从上下文中捕获了两个值，<code>runningTotal</code> 和 <code>amount</code>。捕获这些值之后，<code>makeIncrementor</code> 将 <code>incrementor</code> 作为闭包返回。每次调用 <code>incrementor</code> 时，其会以 <code>amount</code> 作为增量增加 <code>runningTotal</code> 的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementer</span><span class="params">(forIncrement amount: Int)</span></span> -&gt; () -&gt; <span class="type">Int</span> &#123;    <span class="keyword">var</span> runningTotal = <span class="number">0</span>    <span class="function"><span class="keyword">func</span> <span class="title">incrementer</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;        runningTotal += amount        <span class="keyword">return</span> runningTotal    &#125;    <span class="keyword">return</span> incrementer&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> incrementByTen = makeIncrementor(forIncrement: <span class="number">10</span>)</div><div class="line">incrementByTen() <span class="comment">// 返回的值为10 </span></div><div class="line">incrementByTen() <span class="comment">// 返回的值为20 </span></div><div class="line">incrementByTen() <span class="comment">// 返回的值为30</span></div></pre></td></tr></table></figure>
<p>我们单独考虑嵌套函数 incrementer() ，会发现它有些不同寻常:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementer</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;     runningTotal += amount     <span class="keyword">return</span> runningTotal&#125;</div></pre></td></tr></table></figure>
<p><code>incrementer()</code> 函数并没有任何参数，但是在函数体内访问了 <code>runningTotal</code> 和 <code>amount</code> 变量。这是因为它从 外围函数捕获了 <code>runningTotal</code> 和 <code>amount</code> 变量的引用。捕获引用保证了 <code>runningTotal</code> 和 <code>amount</code> 变量在 调用完 <code>makeIncrementer</code> 后不会消失，并且保证了在下一次执行 <code>incrementer</code> 函数时，<code>runningTotal</code> 依旧存 在。</p>
<blockquote>
<p>注意 为了优化，如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份 对值的拷贝。 Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。</p>
</blockquote>
<p>如果你创建了另一个 <code>incrementor</code> ，它会有属于自己的引用，指向一个全新、独立的 <code>runningTotal</code> 变量:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> incrementBySeven = makeIncrementor(forIncrement: <span class="number">7</span>) </div><div class="line">incrementBySeven()<span class="comment">// 返回的值为7</span></div></pre></td></tr></table></figure>
<p>再次调用原来的 <code>incrementByTen</code> 会继续增加它自己的 <code>runningTotal</code> 变量，该变量和 <code>incrementBySeven</code> 中 捕获的变量没有任何联系:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">incrementByTen() <span class="comment">// 返回的值为40</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意: 如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该 实例间创建一个循环强引用。Swift 使用捕获列表来打破这种循环强引用。</p>
</blockquote>
<h3 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h3><p>上面的例子中，<code>incrementBySeven</code> 和<code>incrementByTen</code> 都是常量，但是这些常量指向的闭包仍然可以增加其捕 获的变量的值。这是因为函数和闭包都是引用类型。</p>
<p>无论你将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或变量的值设置为对应函数或闭包的引 用。上面的例子中，指向闭包的引用<code>incrementByTen</code> 是一个常量，而并非闭包内容本身。</p>
<p>这也意味着如果你将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> alsoIncrementByTen = incrementByTen </div><div class="line">alsoIncrementByTen()<span class="comment">// 返回的值为50</span></div></pre></td></tr></table></figure>
<h3 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h3><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当 你定义接受闭包作为参数的函数时，你可以在参数名之前标注 <code>@escaping</code> ，用来指明这个闭包是允许“逃逸”出 这个函数的。</p>
<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异 步操作的函数接受一个闭包参数作为 completion handler。这类函数会在异步操作开始之后立刻返回，但是闭包 直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调 用。例如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = []<span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;    completionHandlers.append(completionHandler)&#125;</div></pre></td></tr></table></figure>
<p><code>someFunctionWithEscapingClosure(_:)</code> 函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组 中。如果你不将这个参数标记为 <code>@escaping</code> ，就会得到一个编译错误。</p>
<p>将一个闭包标记为 <code>@escaping</code> 意味着你必须在闭包中显式地引用 <code>self</code> 。比如说，在下面的代码中，传递到 <code>someFunctionWithEscapingClosure(_:)</code> 中的闭包是一个逃逸闭包，这意味着它需要显式地引用 <code>self</code> 。相对 的，传递到 <code>someFunctionWithNonescapingClosure(_:)</code> 中的闭包是一个非逃逸闭包，这意味着它可以隐式引用<code>self</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithNonescapingClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;    closure()&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">     <span class="keyword">var</span> x = <span class="number">10</span>     <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;         someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x = <span class="number">100</span> &#125;         someFunctionWithNonescapingClosure &#123; x = <span class="number">200</span> &#125;     &#125;&#125;<span class="keyword">let</span> instance = <span class="type">SomeClass</span>() instance.doSomething() <span class="built_in">print</span>(instance.x)<span class="comment">// 打印出 "200"</span>completionHandlers.first?() <span class="built_in">print</span>(instance.x)<span class="comment">// 打印出 "100"</span></div></pre></td></tr></table></figure>
<h3 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h3><p>自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。</p>
<p>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。延迟求值对于那些有副作用(Side Effect)和高计算成本的代码来说是很有益处的，因为它使得你能控制代码的执行时机。下面的代码展示了闭包 如何延时求值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> customersInLine = [<span class="string">"Chris"</span>, <span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</div><div class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</div><div class="line"><span class="comment">// 打印出 "5"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> customerProvider = &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</div><div class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</div><div class="line"><span class="comment">// 打印出 "5"</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</div><div class="line"><span class="comment">// Prints "Now serving Chris!" </span></div><div class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</div><div class="line"><span class="comment">// 打印出 "4"</span></div></pre></td></tr></table></figure>
<p>尽管在闭包的代码中， <code>customersInLine</code>  的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移 除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会执行，那意味着列表中的元素永远不会 被移除。请注意， <code>customerProvider</code>  的类型不是  <code>String</code> ，而是  <code>() -&gt; String</code> ，一个没有参数且返回值为 <code>String</code> 的函数。</p>
<p>将闭包作为参数传递给函数时，你能获得同样的延时求值行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]</span> <span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(customer customerProvider: <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;     <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>) &#125;serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; ) </div><div class="line"><span class="comment">// 打印出 "Now serving Alex!"</span></div></pre></td></tr></table></figure>
<p>上面的 <code>serve(customer:)</code> 函数接受一个返回顾客名字的显式的闭包。下面这个版本的 <code>serve(customer:)</code> 完成 了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为 <code>@autoclosure</code> 来接收一个自动闭 包。现在你可以将该函数当作接受 <code>String</code> 类型参数(而非闭包)的函数来调用。<code>customerProvider</code> 参数将自 动转化为一个闭包，因为该参数被标记了 <code>@autoclosure</code> 特性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// customersInLine is ["Ewa", "Barry", "Daniella"]</span> <span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(customer customerProvider: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;     <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>) &#125;serve(customer: customersInLine.remove(at: <span class="number">0</span>)) </div><div class="line"><span class="comment">// 打印 "Now serving Ewa!"</span></div></pre></td></tr></table></figure>
<p>如果你想让一个自动闭包可以“逃逸”，则应该同时使用 <code>@autoclosure</code> 和 <code>@escaping</code> 属性。<code>@escaping</code> 属 性的讲解见上面的逃逸闭包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// customersInLine i= ["Barry", "Daniella"]</span></div><div class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] = []</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectCustomerProviders</span><span class="params">(<span class="number">_</span> customerProvider: @autoclosure @escaping <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</div><div class="line">    customerProviders.append(customerProvider)</div><div class="line">&#125;</div><div class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</div><div class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</div><div class="line"><span class="built_in">print</span>(<span class="string">"Collected <span class="subst">\(customerProviders.<span class="built_in">count</span>)</span> closures."</span>) <span class="comment">// 打印 "Collected 2 closures."</span></div><div class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "Now serving Barry!"</span></div><div class="line"><span class="comment">// 打印 "Now serving Daniella!"</span></div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/6-函数/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ChefZhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://upload-images.jianshu.io/upload_images/328309-f0893d1d69f1787d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="厨子张">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="厨子张" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/6-函数/" itemprop="url">
                  6.函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T17:37:56+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift基本语法/" itemprop="url" rel="index">
                    <span itemprop="name">swift基本语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/24/6-函数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/24/6-函数/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="多重返回值函数"><a href="#多重返回值函数" class="headerlink" title="多重返回值函数"></a>多重返回值函数</h3><p>你可以用元组(tuple)类型让多个值作为一个复合值从函数中返回。</p>
<p>下例中定义了一个名为 minMax(array:) 的函数，作用是在一个 Int 类型的数组中找出最小值与最大值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>) &#123;</div><div class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</div><div class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</div><div class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</div><div class="line">            currentMin = value</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</div><div class="line">            currentMax = value</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (currentMin, currentMax)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>```swift<br>let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) print(“min is (bounds.min) and max is (bounds.max)”) // 打印 “min is -6 and max is 109”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">### 可选元组返回类型</div><div class="line"></div><div class="line">如果函数返回的元组类型有可能整个元组都“没有值”，你可以使用可选的( `optional` ) 元组返回类型反映 整个元组可以是`nil`的事实。你可以通过在元组类型的右括号后放置一个问号来定义一个可选元组，例如 `(Int, Int)?` 或 `(String, Int, Bool)?`</div><div class="line"></div><div class="line">前面的 `minMax(array:)` 函数返回了一个包含两个 `Int` 值的元组。但是函数不会对传入的数组执行任何安全检 查，如果 `array` 参数是一个空数组，如上定义的 `minMax(array:)` 在试图访问 `array[0]` 时会触发一个运行 时错误`(runtime error)`。</div><div class="line"></div><div class="line">```swift</div><div class="line">func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123;</div><div class="line">    if array.isEmpty &#123; return nil &#125;</div><div class="line">    var currentMin = array[0]</div><div class="line">    var currentMax = array[0]</div><div class="line">    for value in array[1..&lt;array.count] &#123;</div><div class="line">        if value &lt; currentMin &#123;</div><div class="line">            currentMin = value</div><div class="line">        &#125; else if value &gt; currentMax &#123;</div><div class="line">            currentMax = value</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return (currentMin, currentMax)</div><div class="line">&#125;</div><div class="line"></div><div class="line">if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) &#123;</div><div class="line">    print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="函数参数标签和参数名称"><a href="#函数参数标签和参数名称" class="headerlink" title="函数参数标签和参数名称"></a>函数参数标签和参数名称</h3><p>每个函数参数都有一个参数标签( argument label )以及一个参数名称( parameter name )。参数标签在调用函 数的时候使用;调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用。默认情 况下，函数参数使用参数名称来作为它们的参数标签。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(firstParameterName: Int, secondParameterName: Int)</span></span> &#123;<span class="comment">// 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值</span>&#125;someFunction(firstParameterName: <span class="number">1</span>, secondParameterName: <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h4 id="指定参数标签"><a href="#指定参数标签" class="headerlink" title="指定参数标签"></a>指定参数标签</h4><p>你可以在函数名称前指定它的参数标签，中间以空格分隔:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: String, from hometown: String)</span></span> -&gt; <span class="type">String</span> &#123;    <span class="keyword">return</span> <span class="string">"Hello <span class="subst">\(person)</span>!  Glad you could visit from <span class="subst">\(hometown)</span>."</span>&#125;<span class="built_in">print</span>(greet(person: <span class="string">"Bill"</span>, from: <span class="string">"Cupertino"</span>))<span class="comment">// 打印 "Hello Bill! Glad you could visit from Cupertino."</span></div><div class="line"></div><div class="line"><span class="comment">// 参数标签可以写成一样的</span></div><div class="line"><span class="comment">// func greet(name person: String, name hometown: String)</span></div></pre></td></tr></table></figure>
<h4 id="忽略参数标签"><a href="#忽略参数标签" class="headerlink" title="忽略参数标签"></a>忽略参数标签</h4><p>如果你不希望为某个参数添加一个标签，可以使用一个下划线( <code>_</code> )来代替一个明确的参数标签。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(<span class="number">_</span> firstParameterName: Int, secondParameterName: Int)</span></span> &#123;<span class="comment">// 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值</span>&#125;someFunction(<span class="number">1</span>, secondParameterName: <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>你可以在函数体中通过给参数赋值来为任意一个参数定义默认值(Deafult Value)。当默认值被定义后，调用这 个函数时可以忽略这个参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(parameterWithoutDefault: Int, parameterWithDefault: Int = <span class="number">12</span>)</span></span> &#123;<span class="comment">// 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。</span> &#125; someFunction(parameterWithoutDefault: <span class="number">3</span>, parameterWithDefault: <span class="number">6</span>) <span class="comment">// parameterWithDefault = 6</span> someFunction(parameterWithoutDefault: <span class="number">4</span>) <span class="comment">// parameterWithDefault = 12</span></div></pre></td></tr></table></figure>
<p>将不带有默认值的参数放在函数参数列表的最前。一般来说，没有默认值的参数更加的重要，将不带默认值的参<br>数放在最前保证在函数调用时，非默认参数的顺序是一致的，同时也使得相同的函数在不同情况下调用时显得更<br>为清晰。</p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>一个<em>可变参数(variadic parameter)</em>可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数 可以被传入不确定数量的输入值。通过在变量类型名后面加入( … )的方式来定义可变参数。</p>
<p>可变参数的传入值在函数体中变为此类型的一个数组。例如，一个叫做 <code>numbers</code> 的 <code>Double...</code> 型可变参 数，在函数体内可以当做一个叫 <code>numbers</code> 的 <code>[Double]</code> 型的数组常量。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">arithmeticMean</span><span class="params">(<span class="number">_</span> numbers: Double...)</span></span> -&gt; <span class="type">Double</span> &#123;     <span class="keyword">var</span> total: <span class="type">Double</span> = <span class="number">0</span>     <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;         total += number     &#125;     <span class="keyword">return</span> total / <span class="type">Double</span>(numbers.<span class="built_in">count</span>) &#125;arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)<span class="comment">// 返回 3.0, 是这 5 个数的平均数。 </span></div><div class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)<span class="comment">// 返回 10.0, 是这 3 个数的平均数。</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意:<br> 一个函数最多只能拥有一个可变参数。</p>
</blockquote>
<h4 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h4><p>函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误(compile-time error)。这意味着你不能错 误地更改参数值。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那 么就应该把这个参数定义为输入输出参数(In-Out Parameters)</p>
<p>定义一个输入输出参数时，在参数定义前加 inout 关键字。一个输入输出参数有传入函数的值，这个值被函数 修改，然后被传出函数，替换原来的值。</p>
<p>你只能传递变量给输入输出参数。你不能传入常量或者字面量，因为这些量是不能被修改的。当传入的参数作为 输入输出参数时，需要在参数名前加 <code>&amp;</code> 符，表示这个值可以被函数修改。</p>
<p>下例中，  <code>swapTwoInts(_:_:)</code> 函数有两个分别叫做 a 和  b 的输入输出参数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Int, <span class="number">_</span> b: <span class="keyword">inout</span> Int)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> temporaryA = a</div><div class="line">    a = b</div><div class="line">    b = temporaryA</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> someInt = <span class="number">3</span><span class="keyword">var</span> anotherInt = <span class="number">107</span>swapTwoInts(&amp;someInt, &amp;anotherInt)<span class="built_in">print</span>(<span class="string">"someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>"</span>) </div><div class="line"><span class="comment">// 打印 "someInt is now 107, and anotherInt is now 3"</span></div></pre></td></tr></table></figure>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><h4 id="使用函数类型"><a href="#使用函数类型" class="headerlink" title="使用函数类型"></a>使用函数类型</h4><p>在 Swift 中，使用函数类型就像使用其他类型一样。例如，你可以定义一个类型为函数的常量或变量，并将适当 的函数赋值给它:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoInts</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> = addTwoInts</div><div class="line"><span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>)</span>)"</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> demo = addTwoInts</div><div class="line">demo(<span class="number">4</span>, <span class="number">6</span>)</div></pre></td></tr></table></figure>
<h4 id="函数类型作为参数类型"><a href="#函数类型作为参数类型" class="headerlink" title="函数类型作为参数类型"></a>函数类型作为参数类型</h4><p>你可以用 <code>(Int, Int) -&gt; Int</code> 这样的函数类型作为另一个函数的参数类型。这样你可以将函数的一部分实现留给 函数的调用者来提供。</p>
<p>下面是另一个例子，正如上面的函数一样，同样是输出某种数学运算结果:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMathResult</span><span class="params">(<span class="number">_</span> mathFunction: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>, <span class="number">_</span> a: <span class="type">Int</span>, <span class="number">_</span> b: <span class="type">Int</span>) &#123;     <span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(a, b)</span>)"</span>)&#125;printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">// 打印 "Result: 8"</span></div></pre></td></tr></table></figure>
<h4 id="函数类型作为返回类型"><a href="#函数类型作为返回类型" class="headerlink" title="函数类型作为返回类型"></a>函数类型作为返回类型</h4><p>你可以用函数类型作为另一个函数的返回类型。你需要做的是在返回箭头(-&gt;)后写一个完整的函数类型。</p>
<p>下面的这个例子中定义了两个简单函数，分别是 <code>stepForward(_:)</code> 和 <code>stepBackward(_:)</code> 。 <code>stepForward(_:)</code> 函 数返回一个比输入值大 1 的值。<code>stepBackward(_:)</code> 函数返回一个比输入值小 1 的值。这两个函数的类型都 是 (Int) -&gt; Int :</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(<span class="number">_</span> input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;     <span class="keyword">return</span> input + <span class="number">1</span> &#125; <span class="function"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(<span class="number">_</span> input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;     <span class="keyword">return</span> input - <span class="number">1</span> &#125;</div></pre></td></tr></table></figure>
<p>如下名为 <code>chooseStepFunction(backward:)</code> 的函数，它的返回类型是 <code>(Int) -&gt; Int</code> 类型的函数。 <code>chooseStepFunction(backward:)</code> 根据布尔值 <code>backwards</code> 来返回 <code>stepForward(_:)</code> 函数或 <code>stepBackward(_:)</code> 函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backward: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;     <span class="keyword">return</span> backward ? stepBackward : stepForward&#125;</div></pre></td></tr></table></figure>
<p>你现在可以用 <code>chooseStepFunction(backward:)</code> 来获得两个函数其中的一个:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currentValue = <span class="number">3</span><span class="keyword">let</span> moveNearerToZero = chooseStepFunction(backward: currentValue &gt; <span class="number">0</span>) </div><div class="line"><span class="comment">// moveNearerToZero 现在指向 stepBackward() 函数。</span></div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"Counting to zero:"</span>) <span class="comment">// Counting to zero:</span> <span class="keyword">while</span> currentValue != <span class="number">0</span> &#123;     <span class="built_in">print</span>(<span class="string">"<span class="subst">\(currentValue)</span>... "</span>)     currentValue = moveNearerToZero(currentValue) &#125; <span class="built_in">print</span>(<span class="string">"zero!"</span>) <span class="comment">// 3...</span> <span class="comment">// 2...</span> <span class="comment">// 1...</span><span class="comment">// zero!</span></div></pre></td></tr></table></figure>
<h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h3><p>到目前为止本章中你所见到的所有函数都叫全局函数(global functions)，它们定义在全局域中。你也可以把 函数定义在别的函数体中，称作 嵌套函数(nested functions)。</p>
<p>默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数(enclosing function)调用。一个外围 函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。</p>
<p>你可以用返回嵌套函数的方式重写 <code>chooseStepFunction(backward:)</code> 函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backward: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input + <span class="number">1</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input - <span class="number">1</span> &#125;</div><div class="line">    <span class="keyword">return</span> backward ? stepBackward : stepForward</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> currentValue = -<span class="number">4</span></div><div class="line"><span class="keyword">let</span> moveNearerToZero = chooseStepFunction(backward: currentValue &gt; <span class="number">0</span>)</div><div class="line"><span class="comment">// moveNearerToZero now refers to the nested stepForward() function</span></div><div class="line"><span class="keyword">while</span> currentValue != <span class="number">0</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(currentValue)</span>... "</span>)</div><div class="line">    currentValue = moveNearerToZero(currentValue)</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</div><div class="line"><span class="comment">// -4...</span></div><div class="line"><span class="comment">// -3...</span></div><div class="line"><span class="comment">// -2...</span></div><div class="line"><span class="comment">// -1...</span></div><div class="line"><span class="comment">// zero!</span></div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/4-集合类型/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ChefZhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://upload-images.jianshu.io/upload_images/328309-f0893d1d69f1787d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="厨子张">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="厨子张" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/4-集合类型/" itemprop="url">
                  4.集合类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T17:34:47+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift基本语法/" itemprop="url" rel="index">
                    <span itemprop="name">swift基本语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/24/4-集合类型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/24/4-集合类型/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p>Swift 语言中的 <code>Arrays</code> 、 <code>Sets</code> 和 <code>Dictionaries</code> 中存储的数据值类型必须明确。这意味着我们不能把不正确的数 据类型插入其中。同时这也说明我们完全可以对取回值的类型非常自信。</p>
<h3 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h3><h4 id="数组的简单语法"><a href="#数组的简单语法" class="headerlink" title="数组的简单语法"></a>数组的简单语法</h4><p>写 Swift 数组应该遵循像 <code>Array&lt;Element&gt;</code> 这样的形式，其中 Element 是这个数组中唯一允许存在的数据类 型。我们也可以使用像 <code>[Element]</code> 这样的简单语法。尽管两种形式在功能上是一样的，但是推荐较短的那种，而 且在本文中都会使用这种形式来使用数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> someInts = [<span class="type">Int</span>]()<span class="built_in">print</span>(<span class="string">"someInts is of type [Int] with <span class="subst">\(someInts.<span class="built_in">count</span>)</span> items."</span>) <span class="comment">// 打印 "someInts is of type [Int] with 0 items."</span></div></pre></td></tr></table></figure>
<h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><p>我们可以使用 <code>for-in</code> 循环来遍历所有数组中的数据项:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoppingList &#123;    <span class="built_in">print</span>(item)&#125;</div></pre></td></tr></table></figure>
<h3 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合(Sets)"></a>集合(Sets)</h3><p>集合(Set)用来存储相同类型并且没有确定顺序的值。当 合元素顺序不重要时或者希望确保每个元素只出现一次 时可以使用 合而不是数组。</p>
<h4 id="合类型语法"><a href="#合类型语法" class="headerlink" title="合类型语法"></a>合类型语法</h4><p>Swift 中的 <code>Set</code> 类型被写为 <code>Set&lt;Element&gt;</code> ，这里的 <code>Element</code> 表示 <code>Set</code> 中允许存储的类型，和数组不同的是， 集合没有等价的简化形式。</p>
<h4 id="创建和构造一个空的集合"><a href="#创建和构造一个空的集合" class="headerlink" title="创建和构造一个空的集合"></a>创建和构造一个空的集合</h4><p>你可以通过构造器语法创建一个特定类型的空 合:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> letters = <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()<span class="built_in">print</span>(<span class="string">"letters is of type Set&lt;Character&gt; with <span class="subst">\(letters.<span class="built_in">count</span>)</span> items."</span>) <span class="comment">// 打印 "letters is of type Set&lt;Character&gt; with 0 items."</span></div></pre></td></tr></table></figure>
<h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><p>你可以高效地完成 Set 的一些基本操作，比如把两个 合组合到一起，判断两个 合共有元素，或者判断两个  合是否全包含，部分包含或者不相交。</p>
<ul>
<li>使用 <code>intersection(_:)</code> 方法根据两个 合中都包含的值创建的一个新的集合。</li>
<li>使用 <code>symmetricDifference(_:)</code> 方法根据在一个 合中但不在两个 合中的值创建一个新的集合。 </li>
<li>使用 <code>union(_:)</code> 方法根据两个 合的值创建一个新的集合。</li>
<li>使用 <code>subtracting(_:)</code> 方法根据不在该 合中的值创建一个新的集合。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> oddDigits: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]<span class="keyword">let</span> evenDigits: <span class="type">Set</span> = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]<span class="keyword">let</span> singleDigitPrimeNumbers: <span class="type">Set</span> = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]oddDigits.union(evenDigits).<span class="built_in">sort</span>()<span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>oddDigits. intersection(evenDigits).sorted()<span class="comment">// []</span>oddDigits.subtracting(singleDigitPrimeNumbers).sorted()<span class="comment">// [1, 9]</span>oddDigits. symmetricDifference(singleDigitPrimeNumbers).sorted()<span class="comment">// [1, 2, 9]</span></div></pre></td></tr></table></figure>
<h4 id="合成员关系和相等"><a href="#合成员关系和相等" class="headerlink" title="合成员关系和相等"></a>合成员关系和相等</h4><p>下面的插图描述了三个 合- a , b 和 c ,以及通过重叠区域表述 合间共享的元素。 合 a 是 合 b 的父  合，因为 a 包含了 b 中所有的元素，相反的， 合 b 是 合 a 的子 合，因为属于 b 的元素也被 a 包含。 合<br>b 和 合 c 彼此不关联，因为它们之间没有共同的元素。</p>
<ul>
<li>使用“是否相等”运算符( <code>==</code> )来判断两个 合是否包含全部相同的值。</li>
<li>使用 <code>isSubset(of:)</code> 方法来判断一个 合中的值是否也被包含在另外一个 合中。</li>
<li>使用 <code>isSuperset(of:)</code> 方法来判断一个 合中包含另一个 合中所有的值。</li>
<li>使用 <code>isStrictSubset(of:)</code> 或者 <code>isStrictSuperset(of:)</code> 方法来判断一个 合是否是另外一个 合的子 合或 者父 合并且两个 合并不相等。</li>
<li>使用 <code>isDisjoint(with:)</code> 方法来判断两个 合是否不含有相同的值(是否没有交 )。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> houseAnimals: <span class="type">Set</span> = [<span class="string">"?"</span>, <span class="string">"?"</span>]<span class="keyword">let</span> farmAnimals: <span class="type">Set</span> = [<span class="string">"?"</span>, <span class="string">"?"</span>, <span class="string">"?"</span>, <span class="string">"?"</span>, <span class="string">"?"</span>]<span class="keyword">let</span> cityAnimals: <span class="type">Set</span> = [<span class="string">"?"</span>, <span class="string">"?"</span>]houseAnimals.isSubset(of: farmAnimals)<span class="comment">// true</span>farmAnimals.isSuperset(of: houseAnimals)<span class="comment">// true</span>farmAnimals.isDisjoint(with: cityAnimals)<span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><h4 id="创建一个空字典"><a href="#创建一个空字典" class="headerlink" title="创建一个空字典"></a>创建一个空字典</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> namesOfIntegers = <span class="type">Int</span>: <span class="type">String</span><span class="comment">// namesOfIntegers 是一个空的 [Int: String] 字典</span></div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/2.字符和字符串/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ChefZhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://upload-images.jianshu.io/upload_images/328309-f0893d1d69f1787d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="厨子张">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="厨子张" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/2.字符和字符串/" itemprop="url">
                  2.字符和字符串
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T17:21:11+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift基本语法/" itemprop="url" rel="index">
                    <span itemprop="name">swift基本语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/24/2.字符和字符串/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/24/2.字符和字符串/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/1.基础部分/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ChefZhang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://upload-images.jianshu.io/upload_images/328309-f0893d1d69f1787d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="厨子张">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="厨子张" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/1.基础部分/" itemprop="url">
                  1.基础部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T17:01:22+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift基本语法/" itemprop="url" rel="index">
                    <span itemprop="name">swift基本语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/24/1.基础部分/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/24/1.基础部分/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h3 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h3><h4 id="声明常量和变量"><a href="#声明常量和变量" class="headerlink" title="声明常量和变量"></a>声明常量和变量</h4><p>常量和变量必须在使用前声明，用 let 来声明常量，用 var 来声明变量。var和let声明后，会自动判断类型，可以按住option键点击该变量查看</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在swift中，换行的话，会默认添加"；"</span></div><div class="line"><span class="keyword">let</span> maximumNumberOfLoginAttempts = <span class="number">10</span></div><div class="line"><span class="keyword">var</span> currentLoginAttempt = <span class="number">0</span></div></pre></td></tr></table></figure>
<h4 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h4><p>当你声明常量或者变量的时候可以加上类型标注(type annotation)，说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message: <span class="type">String</span></div></pre></td></tr></table></figure>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>Swift 有一个基本的布尔(Boolean)类型，叫做 Bool 。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，true 和 false:   在swift的判断语句中，不再是非假即真的这种判断形势，必须是true和false的判断。例如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> i = <span class="number">1</span></div><div class="line"><span class="keyword">if</span> i &#123;</div><div class="line">    <span class="comment">// 这句就报错了</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h3><p>元组(tuples)把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。元祖的使用与字典类似</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个是一个元祖的定义，元祖是用圆括号抱起来的一组数据；而数组和字典是方括号，千万不要搞错了</span></div><div class="line"><span class="keyword">let</span> http404Error = (<span class="number">404</span>, <span class="string">"Not found"</span>)</div><div class="line"><span class="comment">// http404Error的类型是(Int, String) , 对应的值就是（404, "Not found"）</span></div><div class="line"></div><div class="line"><span class="comment">// 正常的赋值情况就是</span></div><div class="line"><span class="keyword">let</span> (statusCode, statusMessage) = http404Error</div><div class="line"> </div><div class="line"><span class="comment">// 也可以这样， _ 的意思就是该值，没有名称，我并不想用， 所以就会以这种形式去省略掉</span></div><div class="line"><span class="keyword">let</span> (statusCode, <span class="number">_</span>) = http404Error</div></pre></td></tr></table></figure>
<h3 id="可选类型（swift中比较重要的一个特点）"><a href="#可选类型（swift中比较重要的一个特点）" class="headerlink" title="可选类型（swift中比较重要的一个特点）"></a>可选类型（swift中比较重要的一个特点）</h3><p>使用可选类型(optionals)来处理值可能缺失的情况。可选类型表示: </p>
<p>• 有值，等于 x</p>
<p>或者<br>• 没有值</p>
<blockquote>
<p>注意：在OC中，nil是表示“缺少一个合法的对象”，对于结构体、枚举类型或者基本数据类型不起作用。然而，Swift 的可选类型可以让 你暗示任意类型的值缺失，并不需要一个特殊值。 </p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> possibleNumber = <span class="string">"123"</span></div><div class="line"><span class="keyword">let</span> convertedNumber = <span class="type">Int</span>(possibleNumber)</div><div class="line"><span class="comment">// convertedNumber被推断为  Int?  ， 因为字符串可能可以转化为Int，也可能转化不成功</span></div></pre></td></tr></table></figure>
<h4 id="if-语句以及强制解析"><a href="#if-语句以及强制解析" class="headerlink" title="if 语句以及强制解析"></a>if 语句以及强制解析</h4><p>你可以使用 if 语句和 nil 比较来判断一个可选值是否包含值。你可以使用“相等”(==)或“不 等”( != )来执行比较。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber contains some integer value."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出 "convertedNumber contains some integer value."</span></div></pre></td></tr></table></figure>
<h4 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h4><p>使用可选绑定(optional binding)来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 if 和 while 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将 可选类型中的值赋给一个常量或者变量。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> constantName = someOptional &#123;</div><div class="line">    statements</div><div class="line">&#125;</div><div class="line"><span class="comment">// constantName 和 someOptional可以是相同的变量名称</span></div><div class="line"> </div><div class="line"><span class="comment">// 例如，这里右边的name是可选类型，左右的name就是已经解包的类型</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> name = name &#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://upload-images.jianshu.io/upload_images/328309-f0893d1d69f1787d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
               alt="ChefZhang" />
          <p class="site-author-name" itemprop="name">ChefZhang</p>
          <p class="site-description motion-element" itemprop="description">好像没什么比自由更加重要了</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChefZhang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"chefzhang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
