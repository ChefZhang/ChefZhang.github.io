<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Author chefZhang,https://chefzhang.github.io/"><title>14.构造过程 · 朱多多</title><meta name="description" content="构造过程构造过程是使用类、结构体或枚举类型的实例之前的准备过程。在新实例可用前必须执行这个过程，具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作。
与 Objective-C 中的构造器不同，Swift 的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确"><meta name="keywords" content="iOS,Hexo,HTML,CSS"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">朱多多</a></h3><div class="description"><p>机制的朱多多</p></div></div></div><ul class="social-links"><li><a href="http://github.com/https://github.com/ChefZhang"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/archives">Archive</a></li><li><a href="/links">Links</a></li><li><a href="/tag">tag</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="http://upload-images.jianshu.io/upload_images/328309-f0893d1d69f1787d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>14.构造过程</a></h3></div><div class="post-content"><h2 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h2><p>构造过程是使用类、结构体或枚举类型的实例之前的准备过程。在新实例可用前必须执行这个过程，具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作。</p>
<p>与 Objective-C 中的构造器不同，Swift 的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始 化。</p>
<h3 id="存储属性的初始赋值"><a href="#存储属性的初始赋值" class="headerlink" title="存储属性的初始赋值"></a>存储属性的初始赋值</h3><p>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。</p>
<p>你可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。以下小节将详细介绍这两种方法。</p>
<blockquote>
<p>注意<br> 当你为存储型属性设置<strong>默认值</strong>或者在<strong>构造器中为其赋值</strong>时，它们的值是被直接设置的，不会触发任何属性观察者。</p>
</blockquote>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器在创建某个特定类型的新实例时被调用。它的最简形式类似于一个不带任何参数的实例方法，以关键字<code>init</code>命名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">init</span>() &#123;<span class="comment">// 在此处执行构造过程</span>&#125;</div></pre></td></tr></table></figure>
<p>下面例子中定义了一个用来保存华氏温度的结构体<code>Fahrenheit</code> ，它拥有一个<code>Double</code> 类型的存储型属性<code>temperature</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">temperatu<span class="class"><span class="keyword">struct</span> <span class="title">Fahrenheit</span> </span>&#123;    <span class="keyword">var</span> temperature: <span class="type">Double</span>    <span class="keyword">init</span>() &#123;        temperature = <span class="number">32.0</span>    &#125;&#125;<span class="keyword">var</span> f = <span class="type">Fahrenheit</span>()<span class="built_in">print</span>(<span class="string">"The default temperature is <span class="subst">\(f.temperature)</span>° Fahrenheit"</span>) </div><div class="line"><span class="comment">// 打印 "The default temperature is 32.0° Fahrenheit”</span></div></pre></td></tr></table></figure>
<p>这个结构体定义了一个不带参数的构造器 init ，并在里面将存储型属性 temperature 的值初始化为 32.0 (华氏 温度下水的冰点)。</p>
<h4 id="默认属性值"><a href="#默认属性值" class="headerlink" title="默认属性值"></a>默认属性值</h4><p>如前所述，你可以在构造器中为存储型属性设置初始值。同样，你也可以在属性声明时为其设置默认值。</p>
<p>你可以使用更简单的方式在定义结构体 Fahrenheit 时为属性 temperature 设置默认值:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fahrenheit</span> </span>&#123;     <span class="keyword">var</span> temperature = <span class="number">32.0</span>&#125;</div></pre></td></tr></table></figure>
<p>###自定义构造过程<br>你可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中修改常量属性。这些都将在后面章节中提到。</p>
<h4 id="构造参数"><a href="#构造参数" class="headerlink" title="构造参数"></a>构造参数</h4><p>下面例子中定义了一个包含摄氏度温度的结构体 Celsius 。它定义了两个不同的构造器: init(fromFahrenhei t:) 和 init(fromKelvin:) ，二者分别通过接受不同温标下的温度值来创建新的实例:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Celsius</span> </span>&#123;    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span>    <span class="keyword">init</span>(fromFahrenheit fahrenheit: <span class="type">Double</span>) &#123;        temperatureInCelsius = (fahrenheit - <span class="number">32.0</span>) / <span class="number">1.8</span>    &#125;    <span class="keyword">init</span>(fromKelvin kelvin: <span class="type">Double</span>) &#123;        temperatureInCelsius = kelvin - <span class="number">273.15</span>&#125; &#125;<span class="keyword">let</span> boilingPointOfWater = <span class="type">Celsius</span>(fromFahrenheit: <span class="number">212.0</span>) </div><div class="line"><span class="comment">// boilingPointOfWater.temperatureInCelsius 是 100.0</span><span class="keyword">let</span> freezingPointOfWater = <span class="type">Celsius</span>(fromKelvin: <span class="number">273.15</span>) </div><div class="line"><span class="comment">// freezingPointOfWater.temperatureInCelsius 是 0.0</span></div></pre></td></tr></table></figure>
<h4 id="参数的内部名称和外部名称"><a href="#参数的内部名称和外部名称" class="headerlink" title="参数的内部名称和外部名称"></a>参数的内部名称和外部名称</h4><p>如果你定制的类型包含一个逻辑上允许取值为空的存储型属性——无论是因为它无法在初始化时赋值，还是因为 它在之后某个时间点可以赋值为空——你都需要将它定义为 可选类型 。可选类型的属性将自动初始化为 nil ，表 示这个属性是有意在初始化时设置为空的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurveyQuestion</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> text: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> response: <span class="type">String</span>? <span class="comment">// 如果不是可选类型，将会报错，因为init默认是对全部属性都要赋值的</span></div><div class="line">    <span class="keyword">init</span>(text: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.text = text</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ask</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(text)</div><div class="line">    &#125; &#125;</div><div class="line"><span class="keyword">let</span> cheeseQuestion = <span class="type">SurveyQuestion</span>(text: <span class="string">"Do you like cheese?"</span>)</div><div class="line">cheeseQuestion.ask()</div><div class="line"><span class="comment">// 打印 "Do you like cheese?"</span></div><div class="line">cheeseQuestion.response = <span class="string">"Yes, I do like cheese."</span></div></pre></td></tr></table></figure>
<h3 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h3><p>如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默 认构造器(default initializers)。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。</p>
<p>下面例子中创建了一个类<code>ShoppingListItem</code> ，它封装了购物清单中的某一物品的属性:名字(<code>name</code> )、数 量(<code>quantity</code> )和购买状态 <code>purchase state</code> :</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span> </span>&#123;    <span class="keyword">var</span> name: <span class="type">String</span>?    <span class="keyword">var</span> quantity = <span class="number">1</span>    <span class="keyword">var</span> purchased = <span class="literal">false</span>&#125;<span class="keyword">var</span> item = <span class="type">ShoppingListItem</span>()</div></pre></td></tr></table></figure>
<h4 id="结构体的逐一成员构造器"><a href="#结构体的逐一成员构造器" class="headerlink" title="结构体的逐一成员构造器"></a>结构体的逐一成员构造器</h4><p>除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使<br>结构体的存储型属性没有默认值。</p>
<p>逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;     <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span> &#125; <span class="keyword">let</span> twoByTwo = <span class="type">Size</span>(width: <span class="number">2.0</span>, height: <span class="number">2.0</span>)</div></pre></td></tr></table></figure>
<h3 id="值类型的构造器代理"><a href="#值类型的构造器代理" class="headerlink" title="值类型的构造器代理"></a>值类型的构造器代理</h3><p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为==构造器代理==，它能减少多个构造器间的代码重复。</p>
<p>构造器代理的实现规则和形式在值类型和类类型中有所不同。</p>
<p>值类型(结构体和枚举类型)不支持继承，所以构 造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。</p>
<p>类则不同，它可以继承自其它类(请参考继 承)，这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。</p>
<p>对于值类型，你可以使用 self.init 在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内 部调用 <code>self.init</code> 。</p>
<p>如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器(如果是结构体，还将无法访问逐 一成员构造器)。这种限制可以防止你为值类型增加了一个额外的且十分复杂的构造器之后,仍然有人错误的使用 自动生成的构造器</p>
<blockquote>
<p>注意 假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器 写到扩展( extension )中，而不是写在值类型的原始定义中。想查看更多内容，请查看扩展章节。</p>
</blockquote>
<p>```swift<br>struct Size {<br>    var width = 0.0, height = 0.0<br>}<br>struct Point {<br>    var x = 0.0, y = 0.0<br>}<br>struct Rect {<br>    var origin = Point()<br>    var size = Size()<br>    init() {}<br>    init(origin: Point, size: Size) {<br>        self.origin = origin<br>        self.size = size<br>    }<br>    init(center: Point, size: Size) {<br>        let originX = center.x - (size.width / 2)<br>        let originY = center.y - (size.height / 2)<br>        self.init(origin: Point(x: originX, y: originY), size: size)<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 类的继承和构造过程</div><div class="line"></div><div class="line">类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。</div><div class="line"></div><div class="line">Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是***指定构造器***和***便利构造器***。</div><div class="line"></div><div class="line">#### 指定构造器和便利构造器</div><div class="line"></div><div class="line">指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。</div><div class="line"></div><div class="line">每一个类都==必须拥有至少一个指定构造器==。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个 条件。</div><div class="line"></div><div class="line">便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。</div><div class="line"></div><div class="line"></div><div class="line">你应当只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。</div><div class="line"></div><div class="line">#### 指定构造器和便利构造器的语法</div><div class="line"></div><div class="line">类的指定构造器的写法跟值类型简单构造器一样:</div><div class="line"></div><div class="line"></div><div class="line">```swift</div><div class="line">init(parameters) &#123;    statements&#125;</div></pre></td></tr></table></figure></p>
<p>便利构造器也采用相同样式的写法，但需要在 init 关键字之前放置<code>convenience</code> 关键字，并使用空格将它们俩分 开:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(parameters) &#123;    statements&#125;</div></pre></td></tr></table></figure>
<h4 id="类的构造器代理规则"><a href="#类的构造器代理规则" class="headerlink" title="类的构造器代理规则"></a>类的构造器代理规则</h4><p>为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用:</p>
<ul>
<li>指定构造器必须调用其直接父类的的指定构造器。</li>
<li>便利构造器必须调用同类中定义的其它构造器。</li>
<li>便利构造器必须最终导致一个指定构造器被调用。</li>
</ul>
<p>一个更方便记忆的方法是:</p>
<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
<li>便利构造器必须导致一个指定构造器被调用</li>
</ul>
<h4 id="两段式构造过程"><a href="#两段式构造过程" class="headerlink" title="两段式构造过程"></a>两段式构造过程</h4><p>Swift 中类的构造过程包含两个阶段。</p>
<ul>
<li>第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存 储型属性的初始值被确定后。</li>
<li>第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存 储型属性。</li>
</ul>
<p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p>
<blockquote>
<p>注意<br>Swift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C 给每一 个属性赋值 0 或空值(比如说 0 或 nil )。Swift 的构造流程则更加灵活，它允许你设置定制的初始值，并自 如应对某些属性不能以 0 或 nil 作为合法默认值的情况。</p>
</blockquote>
<p>Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程能不出错地完成:</p>
<ul>
<li>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。(如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器<br>必须保证它所在类引入的属性在它往上代理之前先完成初始化。)</li>
<li>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的 新值将被父类中的构造器所覆盖。</li>
<li>便利构造器<strong><em>必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值</em></strong>。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。</li>
<li>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个 值。</li>
</ul>
<p>类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性<br>和调用方法。</p>
<h4 id="构造器的继承和重写"><a href="#构造器的继承和重写" class="headerlink" title="构造器的继承和重写"></a>构造器的继承和重写</h4><p>跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止 一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。</p>
<blockquote>
<p>注意<br>父类的构造器仅会在安全和适当的情况下被继承。具体内容请参考后续章节构造器的自动继承 (页 0)。</p>
</blockquote>
<p>假如你希望自定义的子类中能提供一个或多个跟父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。</p>
<p>当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因 此，你必须在定义子类构造器时带上 <code>override</code>  修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上<code>override</code>修饰符</p>
<blockquote>
<p>注意<br>当你重写一个父类的指定构造器时，你总是需要写   修饰符，即使你的子类将父类的指定构造器重写为 了便利构造器。</p>
</blockquote>
<p>相反，如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器，因此，严格意义上来讲，你的子类并未对一个父类构造 器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加 <code>override</code>  前缀。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;     <span class="keyword">var</span> numberOfWheels = <span class="number">0</span>     <span class="keyword">var</span> description: <span class="type">String</span> &#123;         <span class="keyword">return</span> <span class="string">"<span class="subst">\(numberOfWheels)</span> wheel(s)"</span>     &#125;&#125;</div></pre></td></tr></table></figure>
<p>类只为存储型属性提供默认值，而不自定义构造器。因此，它会自动获得一个默认构造器。自动获得的默认构造器总会是类中的指定构造器，它可以用于创建  <code>numberOfWheels</code> 为<code>0</code>的  <code>Vehicle</code> 实例:</p>
<p>下面例子中定义了一个<code>Vehicle</code> 的子类<code>Bicycle</code> :</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span>: <span class="title">Vehicle</span> </span>&#123;     <span class="keyword">override</span> <span class="keyword">init</span>() &#123;         <span class="keyword">super</span>.<span class="keyword">init</span>()         numberOfWheels = <span class="number">2</span>     &#125;&#125;</div></pre></td></tr></table></figure>
<p>子类 Bicycle 定义了一个自定义指定构造器 <code>init()</code> 。这个指定构造器和父类的指定构造器相匹配，所以<code>Bicycle</code> 中的指定构造器需要带上<code>override</code> 修饰符。</p>
<h4 id="构造器的自动继承"><a href="#构造器的自动继承" class="headerlink" title="构造器的自动继承"></a>构造器的自动继承</h4><p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。</p>
<p>假设你为子类中引入的==所有新属性都提供了默认值==，以下 2 个规则适用:</p>
<ul>
<li>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</li>
<li>如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将 自动继承所有父类的便利构造器。</li>
</ul>
<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。</p>
<blockquote>
<p>注意<br>对于规则 2，子类可以将父类的指定构造器实现为便利构造器。</p>
</blockquote>
<h4 id="指定构造器和便利构造器实践"><a href="#指定构造器和便利构造器实践" class="headerlink" title="指定构造器和便利构造器实践"></a>指定构造器和便利构造器实践</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;     <span class="keyword">var</span> name: <span class="type">String</span>     <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;         <span class="keyword">self</span>.name = name     &#125;     <span class="keyword">convenience</span> <span class="keyword">init</span>() &#123;         <span class="keyword">self</span>.<span class="keyword">init</span>(name: <span class="string">"[Unnamed]"</span>)	&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类类型没有默认的逐一成员构造器，所以 Food 类提供了一个接受单一参数 name 的指定构造器。</p>
<p>Food 类同样提供了一个没有参数的便利构造器 init() 。这个 init() 构造器为新食物提供了一个默认的占位名 字，通过横向代理到指定构造器 init(name: String) 并给参数 name 传值 [Unnamed] 来实现:</p>
<p>类层级中的第二个类是 Food 的子类 RecipeIngredient 。 RecipeIngredient 类用来表示食谱中的一项原料。它引 入了 Int 类型的属性 quantity (以及从 Food 继承过来的 name 属性)，并且定义了两个构造器来创建 RecipeIng redient 实例:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipeIngredient</span>: <span class="title">Food</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.quantity = quantity</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</div><div class="line">    &#125;</div><div class="line"><span class="comment">//    override init(name: String) &#123;</span></div><div class="line"><span class="comment">//        // 必须调用父类的指定构造器</span></div><div class="line"><span class="comment">//        // 不能调用super.init</span></div><div class="line"><span class="comment">//        super.init(name: "asdf")</span></div><div class="line"><span class="comment">//        self.name = "asdf"</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"></div><div class="line">    <span class="comment">// 只要忽略掉convenience就明白为啥要用override了</span></div><div class="line">    <span class="comment">// convenience只是一个便利构造器的意思</span></div><div class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, quantity: <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> recipe = <span class="type">RecipeIngredient</span>(name: <span class="string">"你好"</span>)</div><div class="line"><span class="built_in">print</span>(recipe.name, recipe.quantity)</div></pre></td></tr></table></figure>
<p>注意， <code>RecipeIngredient</code>  的便利构造器 <code>init(name: String)</code>使用了跟  <code>Food</code> 中指定构造器<code>init(name: String)</code>相同的参数。由于这个便利构造器重写了父类的指定构造器<code>init(name: String)</code>，因此必须在前面加<code>override</code>修饰。</p>
<p>尽管<code>RecipeIngredient</code>将父类的指定构造器重写为便利构造器，它依然提供了父类的所有指定构造器的实现。因此，<code>RecipeIngredient</code>会自动继承父类的所有便利构造器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: <span class="string">"[Unnamed]"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> foodd = <span class="type">Food</span>()</div><div class="line"><span class="built_in">print</span>(foodd.name)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipeIngredient</span>: <span class="title">Food</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.quantity = quantity</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, quantity: <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> recipe = <span class="type">RecipeIngredient</span>(name: <span class="string">"你好"</span>)</div><div class="line"><span class="built_in">print</span>(recipe.name, recipe.quantity)</div><div class="line"></div><div class="line"><span class="comment">// 就是这个啦</span></div><div class="line"><span class="keyword">let</span> test = <span class="type">RecipeIngredient</span>()</div><div class="line"><span class="built_in">print</span>(test.name)</div></pre></td></tr></table></figure>
<p>类层级中第三个也是最后一个类是<code>RecipeIngredient</code>的子类，叫做<code>ShoppingListItem</code>。这个类构建了购物单中出现的某一种食谱原料。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span>: <span class="title">RecipeIngredient</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> purchased = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">var</span> output = <span class="string">"<span class="subst">\(quantity)</span> x <span class="subst">\(name)</span>"</span></div><div class="line">        output += purchased ? <span class="string">" ?"</span> : <span class="string">" ?"</span></div><div class="line">        <span class="keyword">return</span> output</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，<code>ShoppingListItem</code> 将自动继承所 有父类中的指定构造器和便利构造器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> breakfastList = [     <span class="type">ShoppingListItem</span>(),     <span class="type">ShoppingListItem</span>(name: <span class="string">"Bacon"</span>),     <span class="type">ShoppingListItem</span>(name: <span class="string">"Eggs"</span>, quantity: <span class="number">6</span>), ] breakfastList[<span class="number">0</span>].name = <span class="string">"Orange juice"</span> breakfastList[<span class="number">0</span>].purchased = <span class="literal">true</span> <span class="keyword">for</span> item <span class="keyword">in</span> breakfastList &#123;     <span class="built_in">print</span>(item.description) &#125; <span class="comment">// 1 x orange juice ?</span> <span class="comment">// 1 x bacon ?</span> <span class="comment">// 6 x eggs ?</span></div></pre></td></tr></table></figure>
<h3 id="可失败构造器"><a href="#可失败构造器" class="headerlink" title="可失败构造器"></a>可失败构造器</h3><p>如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器。这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。</p>
<p>为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或 多个可失败构造器。其语法为在<code>init</code> 关键字后面添加问号( <code>init?</code> )。</p>
<blockquote>
<p>注意<br> 可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。</p>
</blockquote>
<p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过 <code>return nil</code> 语句来表明可失败构造器在何种 情况下应该“失败”。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> species: <span class="type">String</span></div><div class="line">    <span class="keyword">init</span>?(species: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">if</span> species.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">        <span class="keyword">self</span>.species = species</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> someCreature = <span class="type">Animal</span>(species: <span class="string">"Giraffe"</span>) </div><div class="line"><span class="comment">// someCreature 的类型是 Animal? 而不是 Animal</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> giraffe = someCreature &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"An animal was initialized with a species of <span class="subst">\(giraffe.species)</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> anonymousCreature = <span class="type">Animal</span>(species: <span class="string">""</span>)</div><div class="line"><span class="comment">// anonymousCreature 的类型是 Animal?, 而不是 Animal</span></div><div class="line"><span class="keyword">if</span> anonymousCreature == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The anonymous creature could not be initialized"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="枚举类型的可失败构造器"><a href="#枚举类型的可失败构造器" class="headerlink" title="枚举类型的可失败构造器"></a>枚举类型的可失败构造器</h4><p>你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Kelvin</span>, <span class="type">Celsius</span>, <span class="type">Fahrenheit</span></div><div class="line">    <span class="keyword">init</span>?(symbol: <span class="type">Character</span>) &#123;</div><div class="line">        <span class="keyword">switch</span> symbol &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"K"</span>:</div><div class="line">            <span class="keyword">self</span> = .<span class="type">Kelvin</span></div><div class="line">        <span class="keyword">case</span> <span class="string">"C"</span>:</div><div class="line">            <span class="keyword">self</span> = .<span class="type">Celsius</span></div><div class="line">        <span class="keyword">case</span> <span class="string">"F"</span>:</div><div class="line">            <span class="keyword">self</span> = .<span class="type">Fahrenheit</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="带原始值的枚举类型的可失败构造器"><a href="#带原始值的枚举类型的可失败构造器" class="headerlink" title="带原始值的枚举类型的可失败构造器"></a>带原始值的枚举类型的可失败构造器</h4><p>带原始值的枚举类型会自带一个可失败构造器 <code>init?(rawValue:)</code> ，该可失败构造器有一个名为<code>rawValue</code> 的参 数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构 造相应的枚举成员，否则构造失败。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit2</span>: <span class="title">Character</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Kelvin</span> = <span class="string">"K"</span>, <span class="type">Celsius</span> = <span class="string">"C"</span>, <span class="type">Fahrenheit</span> = <span class="string">"F"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> fahrenheitUnit = <span class="type">TemperatureUnit2</span>(rawValue: <span class="string">"1"</span>);</div></pre></td></tr></table></figure>
<h4 id="构造失败的传递"><a href="#构造失败的传递" class="headerlink" title="构造失败的传递"></a>构造失败的传递</h4><p>类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。</p>
<p>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。</p>
<blockquote>
<p>注意<br> 可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">if</span> name.isEmpty &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarItem</span>: <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> quantity: <span class="type">Int</span></div><div class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</div><div class="line">        <span class="keyword">if</span> quantity &lt; <span class="number">1</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">self</span>.quantity = quantity</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="重写一个可失败构造器"><a href="#重写一个可失败构造器" class="headerlink" title="重写一个可失败构造器"></a>重写一个可失败构造器</h4><p>如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。</p>
<blockquote>
<p>注意，当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。<br>注意<br>你可以用非可失败构造器重写可失败构造器，但反过来却不行。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 子类的非可失败构造器重写父类的可失败构造器</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</div><div class="line">    <span class="comment">// String?的原因是因为，如果没有可选类型，那么所有的属性在init()中就都要赋值</span></div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">    <span class="keyword">init</span>() &#123;&#125;</div><div class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</div><div class="line">    	<span class="keyword">self</span>.name = name</div><div class="line">    	<span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticallyNamedDocument</span>: <span class="title">Document</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">        name = <span class="string">"[Untitled]"</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">        <span class="keyword">if</span> name.isEmpty &#123;</div><div class="line">            <span class="keyword">self</span>.name = <span class="string">"[Untitled]"</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">self</span>.name = name</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AutomaticallyNamedDocument</code>用一个非可失败构造器 <code>init(name:)</code> 重写了父类的可失败构造器 <code>init?(name:)</code> 。因 为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器 代替了父类的可失败构造器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 子类重写父类可失败构造方法</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</div><div class="line">    <span class="comment">// String?的原因是因为，如果没有可选类型，那么所有的属性在init()中就都要赋值</span></div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">    <span class="keyword">init</span>() &#123;&#125;</div><div class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticallyNamedDocument</span>: <span class="title">Document</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">        name = <span class="string">"[Untitled]"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">if</span> name.isEmpty &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"这是空的"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> auto = <span class="type">AutomaticallyNamedDocument</span>(name: <span class="string">""</span>)</div></pre></td></tr></table></figure>
<p>你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如，下面的<code>UntitledDocument</code> 子 类的<code>name</code> 属性的值总是 <code>&quot;[Untitled]&quot;</code> ，它在构造过程中使用了父类的可失败构造器 <code>init?(name:)</code> :</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticallyNamedDocument</span>: <span class="title">Document</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"[Untitled]"</span>)!</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">if</span> name.isEmpty &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"这是空的"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> auto = <span class="type">AutomaticallyNamedDocument</span>(name: <span class="string">""</span>)</div><div class="line"><span class="keyword">let</span> asdf = <span class="type">AutomaticallyNamedDocument</span>()</div></pre></td></tr></table></figure>
<h4 id="可失败构造器-init"><a href="#可失败构造器-init" class="headerlink" title="可失败构造器 init!"></a>可失败构造器 init!</h4><p>通常来说我们通过在<code>init</code> 关键字后添加问号的方式( <code>init?</code> )来定义一个可失败构造器，但你也可以通过在 <code>init</code> 后面添加惊叹号的方式来定义一个可失败构造器( <code>init!</code> )，该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。</p>
<p>你可以在 <code>init?</code> 中代理到 <code>init!</code> ，反之亦然。你也可以用 <code>init?</code> 重写 <code>init!</code> ，反之亦然。你还可以用<code>init</code> 代理 到 <code>init!</code> ，不过，一旦 <code>init!</code> 构造失败，则会触发一个断言。</p>
<h3 id="必要构造器"><a href="#必要构造器" class="headerlink" title="必要构造器"></a>必要构造器</h3><p>在类的构造器前添加<code>required</code> 修饰符表明所有该类的子类都必须实现该构造器:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="comment">// 构造器的实现代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加<code>required</code> 修饰符，表明该构造器要求也应用于继 承链后面的子类。在重写父类中必要的指定构造器时，==不需要添加== <code>override</code> 修饰符:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubclass</span>: <span class="title">SomeClass</span> </span>&#123;     <span class="keyword">required</span> <span class="keyword">init</span>() &#123;		<span class="comment">// 构造器的实现代码 </span></div><div class="line">	&#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="通过闭包或函数设置属性的默认值"><a href="#通过闭包或函数设置属性的默认值" class="headerlink" title="通过闭包或函数设置属性的默认值"></a>通过闭包或函数设置属性的默认值</h3><p>如果某个存储型属性的默认值需要一些定制或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。</p>
<p>下面介绍了如何用闭包为属性提供默认值:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> someProperty: <span class="type">SomeType</span> = &#123;</div><div class="line">        <span class="comment">// 在这个闭包中给 someProperty 创建一个默认值 // someValue 必须和 SomeType 类型相同</span></div><div class="line">        <span class="keyword">return</span> someValue</div><div class="line">    &#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括 号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>
<blockquote>
<p>注意<br>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包 里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的 self 属性，或者调用任何实例方法。</p>
</blockquote>
<p>下面是国际象棋的棋盘</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Checkerboard</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> boardColors: [<span class="type">Bool</span>] = &#123;</div><div class="line">        <span class="keyword">var</span> temporaryBoard = [<span class="type">Bool</span>]()</div><div class="line">        <span class="keyword">var</span> isBlack = <span class="literal">false</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">8</span> &#123;</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">8</span> &#123;</div><div class="line">                temporaryBoard.append(isBlack)</div><div class="line">                isBlack = !isBlack</div><div class="line">            &#125;</div><div class="line">            isBlack = !isBlack</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> temporaryBoard</div><div class="line">    &#125;()</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">squareIsBlackAtRow</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> boardColors[(row * <span class="number">8</span>) + column]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-02-24</span><i class="fa fa-tag"></i><a class="tag" href="/categories/swift基本语法/" title="swift基本语法">swift基本语法 </a><a class="tag" href="/tags/swift/" title="swift">swift </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2017/02/24/14-构造过程/,朱多多,14.构造过程,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/02/24/15-析构过程/" title="15.析构过程">Prev post</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2017/02/24/13-继承/" title="13.继承">Next post</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'cCvO1WkU4CxdrgVlL1xVKUGy-gzGzoHsz',
  app_key:'LVDXkJkVmzeGKLMytUjKz6Fm',
  placeholder:'Just go go',
  path: window.location.pathname,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>